From 0bb5ffc46a21ceb635066d1ea88a382d0dba883f Mon Sep 17 00:00:00 2001
From: Brendan William <brendan.william@outlook.com>
Date: Thu, 26 Jan 2023 14:42:09 -0800
Subject: [PATCH 01/27] Revert "wayland/pointer-constraints: Adjustments for
 subsurface support"

This reverts commit f7b86a00c4793d5c543f0cdfe7b39df1d762f678.
---
 src/wayland/meta-wayland-pointer-constraints.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/wayland/meta-wayland-pointer-constraints.c b/src/wayland/meta-wayland-pointer-constraints.c
index 598b5fcd28..965b95ddad 100644
--- a/src/wayland/meta-wayland-pointer-constraints.c
+++ b/src/wayland/meta-wayland-pointer-constraints.c
@@ -39,7 +39,6 @@
 #include "wayland/meta-wayland-private.h"
 #include "wayland/meta-wayland-region.h"
 #include "wayland/meta-wayland-seat.h"
-#include "wayland/meta-wayland-subsurface.h"
 #include "wayland/meta-wayland-surface.h"
 #include "wayland/meta-xwayland.h"
 
@@ -194,6 +193,8 @@ surface_constraint_data_new (MetaWaylandSurface *surface)
     }
   else
     {
+      /* TODO: Support constraints on non-toplevel windows, such as subsurfaces.
+       */
       g_warn_if_reached ();
     }
 
@@ -462,10 +463,8 @@ should_constraint_be_enabled (MetaWaylandPointerConstraint *constraint)
       /*
        * Locks from Xwayland may come before we have had the opportunity to
        * associate the X11 Window with the wl_surface.
-       * For subsurfaces the window of the ancestor might be gone already.
        */
-      g_warn_if_fail (meta_xwayland_is_xwayland_surface (constraint->surface) ||
-                      META_IS_WAYLAND_SUBSURFACE (constraint->surface->role));
+      g_warn_if_fail (meta_xwayland_is_xwayland_surface (constraint->surface));
       return FALSE;
     }
 
-- 
2.39.1


From 72d3e8cda2636080a7c575d02e29fd57ee1c136a Mon Sep 17 00:00:00 2001
From: Brendan William <brendan.william@outlook.com>
Date: Thu, 26 Jan 2023 14:42:13 -0800
Subject: [PATCH 02/27] Revert "wayland/subsurface: Check ancestor instead of
 toplevel window for actor sync"

This reverts commit f4366049ba2ee1c44ca23fbbc8a1e7737e929b04.
---
 src/wayland/meta-wayland-subsurface.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index f044c525b9..5441e750c3 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -266,8 +266,10 @@ meta_wayland_subsurface_sync_actor_state (MetaWaylandActorSurface *actor_surface
     meta_wayland_surface_role_get_surface (surface_role);
   MetaWaylandActorSurfaceClass *actor_surface_class =
     META_WAYLAND_ACTOR_SURFACE_CLASS (meta_wayland_subsurface_parent_class);
+  MetaWaylandSurface *toplevel_surface;
 
-  if (meta_wayland_surface_get_window (surface))
+  toplevel_surface = meta_wayland_surface_get_toplevel (surface);
+  if (toplevel_surface && meta_wayland_surface_get_window (toplevel_surface))
     actor_surface_class->sync_actor_state (actor_surface);
 
   sync_actor_subsurface_state (surface);
-- 
2.39.1


From c9070106537c96f33c3609dbe2d692c12b3af82c Mon Sep 17 00:00:00 2001
From: Brendan William <brendan.william@outlook.com>
Date: Thu, 26 Jan 2023 14:42:17 -0800
Subject: [PATCH 03/27] Revert "wayland/subsurface: Implement
 meta_wayland_surface_get_window()"

This reverts commit a036bfb7fdfaafd1c05fac959d3ef5302fc81516.
---
 src/wayland/meta-wayland-subsurface.c | 15 ---------------
 1 file changed, 15 deletions(-)

diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index 5441e750c3..6a23c86100 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -193,20 +193,6 @@ meta_wayland_subsurface_get_toplevel (MetaWaylandSurfaceRole *surface_role)
     return NULL;
 }
 
-static MetaWindow *
-meta_wayland_subsurface_get_window (MetaWaylandSurfaceRole *surface_role)
-{
-  MetaWaylandSurface *surface =
-    meta_wayland_surface_role_get_surface (surface_role);
-  MetaWaylandSurface *parent;
-
-  parent = surface->sub.parent;
-  if (parent)
-    return meta_wayland_surface_get_window (parent);
-  else
-    return NULL;
-}
-
 static gboolean
 meta_wayland_subsurface_should_cache_state (MetaWaylandSurfaceRole *surface_role)
 {
@@ -290,7 +276,6 @@ meta_wayland_subsurface_class_init (MetaWaylandSubsurfaceClass *klass)
 
   surface_role_class->assigned = meta_wayland_subsurface_assigned;
   surface_role_class->get_toplevel = meta_wayland_subsurface_get_toplevel;
-  surface_role_class->get_window = meta_wayland_subsurface_get_window;
   surface_role_class->should_cache_state = meta_wayland_subsurface_should_cache_state;
   surface_role_class->notify_subsurface_state_changed =
     meta_wayland_subsurface_notify_subsurface_state_changed;
-- 
2.39.1


From 058cbcd791180062023d96cf7b2bd6bad76534d4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Sat, 22 May 2021 18:32:44 +0200
Subject: [PATCH 04/27] wayland/dma-buf: Add
 meta_wayland_dma_buf_fds_for_wayland_buffer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

And call it from meta_wayland_buffer_realize. This makes dma-buf fds
available for EGL image type buffers as well.

v2:
* Move buffer->dma_buf.dma_buf assignment value to next line.
  (Jonas Ådahl)

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-buffer.c  |  2 ++
 src/wayland/meta-wayland-dma-buf.c | 52 +++++++++++++++++++++++++++++-
 src/wayland/meta-wayland-dma-buf.h |  3 ++
 3 files changed, 56 insertions(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-buffer.c b/src/wayland/meta-wayland-buffer.c
index 7a22f824bc..910d5edc4f 100644
--- a/src/wayland/meta-wayland-buffer.c
+++ b/src/wayland/meta-wayland-buffer.c
@@ -184,6 +184,8 @@ meta_wayland_buffer_realize (MetaWaylandBuffer *buffer)
                                          NULL))
         {
           buffer->type = META_WAYLAND_BUFFER_TYPE_EGL_IMAGE;
+          buffer->dma_buf.dma_buf =
+            meta_wayland_dma_buf_fds_for_wayland_buffer (buffer);
           return TRUE;
         }
     }
diff --git a/src/wayland/meta-wayland-dma-buf.c b/src/wayland/meta-wayland-dma-buf.c
index 350be1618f..cc74afad57 100644
--- a/src/wayland/meta-wayland-dma-buf.c
+++ b/src/wayland/meta-wayland-dma-buf.c
@@ -689,6 +689,56 @@ static const struct wl_buffer_interface dma_buf_buffer_impl =
   buffer_destroy,
 };
 
+/**
+ * meta_wayland_dma_buf_fds_for_wayland_buffer:
+ * @buffer: A #MetaWaylandBuffer object
+ *
+ * Creates an associated #MetaWaylandDmaBufBuffer for the wayland buffer, which
+ * contains just the dma-buf file descriptors.
+ *
+ * Returns: The new #MetaWaylandDmaBufBuffer (or
+ * %NULL if it couldn't be created)
+ */
+MetaWaylandDmaBufBuffer *
+meta_wayland_dma_buf_fds_for_wayland_buffer (MetaWaylandBuffer *buffer)
+{
+#ifdef HAVE_NATIVE_BACKEND
+  MetaBackend *backend = meta_get_backend ();
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+  MetaGpuKms *gpu_kms;
+  struct gbm_device *gbm_device;
+  struct gbm_bo *gbm_bo;
+  MetaWaylandDmaBufBuffer *dma_buf;
+  uint32_t i, n_planes;
+
+  gpu_kms = meta_renderer_native_get_primary_gpu (renderer_native);
+  if (!gpu_kms)
+    return NULL;
+
+  gbm_device = meta_gbm_device_from_gpu (gpu_kms);
+
+  gbm_bo = gbm_bo_import (gbm_device,
+                          GBM_BO_IMPORT_WL_BUFFER, buffer->resource,
+                          GBM_BO_USE_RENDERING);
+  if (!gbm_bo)
+    return NULL;
+
+  dma_buf = g_object_new (META_TYPE_WAYLAND_DMA_BUF_BUFFER, NULL);
+
+  n_planes = gbm_bo_get_plane_count (gbm_bo);
+  for (i = 0; i < n_planes; i++)
+    dma_buf->fds[i] = gbm_bo_get_fd_for_plane (gbm_bo, i);
+  while (i < META_WAYLAND_DMA_BUF_MAX_FDS)
+    dma_buf->fds[i++] = -1;
+
+  gbm_bo_destroy (gbm_bo);
+  return dma_buf;
+#else
+  return NULL;
+#endif
+}
+
 /**
  * meta_wayland_dma_buf_from_buffer:
  * @buffer: A #MetaWaylandBuffer object
@@ -710,7 +760,7 @@ meta_wayland_dma_buf_from_buffer (MetaWaylandBuffer *buffer)
                                &dma_buf_buffer_impl))
     return wl_resource_get_user_data (buffer->resource);
 
-  return NULL;
+  return buffer->dma_buf.dma_buf;
 }
 
 static void
diff --git a/src/wayland/meta-wayland-dma-buf.h b/src/wayland/meta-wayland-dma-buf.h
index dc1231560b..57b1ef68e8 100644
--- a/src/wayland/meta-wayland-dma-buf.h
+++ b/src/wayland/meta-wayland-dma-buf.h
@@ -51,6 +51,9 @@ meta_wayland_dma_buf_buffer_attach (MetaWaylandBuffer  *buffer,
                                     CoglTexture       **texture,
                                     GError            **error);
 
+MetaWaylandDmaBufBuffer *
+meta_wayland_dma_buf_fds_for_wayland_buffer (MetaWaylandBuffer *buffer);
+
 MetaWaylandDmaBufBuffer *
 meta_wayland_dma_buf_from_buffer (MetaWaylandBuffer *buffer);
 
-- 
2.39.1


From 8d3e8113f6b1d53dd80fe9b189cba2a1076ce47e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 10 Jun 2022 16:40:10 +0200
Subject: [PATCH 05/27] wayland/dma-buf: Add meta_wayland_dma_buf_create_source
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Creates a GSource which will call the specified dispatch callback when
all dma-buf file descriptors for the buffer have become readable.

v2:
* Hold a reference to the buffer in the source, to prevent the buffer
  from getting destroyed before the source.
v3:
* Do not use check callback, handle everything in dispatch callback.
  (Dor Askayo)
v4: (Georges Basile Stavracas Neto)
* Define and use MetaWaylandDmaBufSource & MetaWaylandDmaBufSourceDispatch
  types.
* Fix meta_wayland_dma_buf_source_dispatch &
  meta_wayland_dma_buf_source_funcs formatting.
* Use gpointer instead of void*.
* Rename meta_wayland_dma_buf_get_source to
  meta_wayland_dma_buf_create_source. (Carlos Garnacho)
v5:
* Explicitly handle NULL return value. (Jonas Ådahl)
v6:
* Fix style issue per check-style.py.
v7:
* Fix code style harder. (Jonas Ådahl)

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-dma-buf.c | 147 +++++++++++++++++++++++++++++
 src/wayland/meta-wayland-dma-buf.h |   8 ++
 2 files changed, 155 insertions(+)

diff --git a/src/wayland/meta-wayland-dma-buf.c b/src/wayland/meta-wayland-dma-buf.c
index cc74afad57..05e812eca1 100644
--- a/src/wayland/meta-wayland-dma-buf.c
+++ b/src/wayland/meta-wayland-dma-buf.c
@@ -763,6 +763,153 @@ meta_wayland_dma_buf_from_buffer (MetaWaylandBuffer *buffer)
   return buffer->dma_buf.dma_buf;
 }
 
+typedef struct _MetaWaylandDmaBufSource
+{
+  GSource base;
+
+  MetaWaylandDmaBufSourceDispatch dispatch;
+  MetaWaylandBuffer *buffer;
+  gpointer user_data;
+
+  gpointer fd_tags[META_WAYLAND_DMA_BUF_MAX_FDS];
+} MetaWaylandDmaBufSource;
+
+static gboolean
+meta_wayland_dma_buf_fd_readable (int fd)
+{
+  GPollFD poll_fd;
+
+  poll_fd.fd = fd;
+  poll_fd.events = G_IO_IN;
+  poll_fd.revents = 0;
+
+  if (!g_poll (&poll_fd, 1, 0))
+    return FALSE;
+
+  return (poll_fd.revents & (G_IO_IN | G_IO_NVAL)) != 0;
+}
+
+static gboolean
+meta_wayland_dma_buf_source_dispatch (GSource     *base,
+                                      GSourceFunc  callback,
+                                      gpointer     user_data)
+{
+  MetaWaylandDmaBufSource *source;
+  MetaWaylandDmaBufBuffer *dma_buf;
+  gboolean ready;
+  uint32_t i;
+
+  source = (MetaWaylandDmaBufSource *) base;
+  dma_buf = source->buffer->dma_buf.dma_buf;
+  ready = TRUE;
+
+  for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
+    {
+      gpointer fd_tag = source->fd_tags[i];
+
+      if (!fd_tag)
+        continue;
+
+      if (!meta_wayland_dma_buf_fd_readable (dma_buf->fds[i]))
+        {
+          ready = FALSE;
+          continue;
+        }
+
+      g_source_remove_unix_fd (&source->base, fd_tag);
+      source->fd_tags[i] = NULL;
+    }
+
+  if (!ready)
+    return G_SOURCE_CONTINUE;
+
+  source->dispatch (source->buffer, source->user_data);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+meta_wayland_dma_buf_source_finalize (GSource *base)
+{
+  MetaWaylandDmaBufSource *source;
+  uint32_t i;
+
+  source = (MetaWaylandDmaBufSource *) base;
+
+  for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
+    {
+      gpointer fd_tag = source->fd_tags[i];
+
+      if (fd_tag)
+        {
+          g_source_remove_unix_fd (&source->base, fd_tag);
+          source->fd_tags[i] = NULL;
+        }
+    }
+
+  g_clear_object (&source->buffer);
+}
+
+static GSourceFuncs meta_wayland_dma_buf_source_funcs = {
+  .dispatch = meta_wayland_dma_buf_source_dispatch,
+  .finalize = meta_wayland_dma_buf_source_finalize
+};
+
+/**
+ * meta_wayland_dma_buf_create_source:
+ * @buffer: A #MetaWaylandBuffer object
+ * @dispatch: Callback
+ * @user_data: User data for the callback
+ *
+ * Creates a GSource which will call the specified dispatch callback when all
+ * dma-buf file descriptors for the buffer have become readable.
+ *
+ * Returns: The new GSource (or
+ * %NULL if there are no dma-buf file descriptors, or they were all readable
+ * already)
+ */
+GSource *
+meta_wayland_dma_buf_create_source (MetaWaylandBuffer               *buffer,
+                                    MetaWaylandDmaBufSourceDispatch  dispatch,
+                                    gpointer                         user_data)
+{
+  MetaWaylandDmaBufBuffer *dma_buf;
+  MetaWaylandDmaBufSource *source = NULL;
+  uint32_t i;
+
+  dma_buf = buffer->dma_buf.dma_buf;
+  if (!dma_buf)
+    return NULL;
+
+  for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
+    {
+      int fd = dma_buf->fds[i];
+
+      if (fd < 0)
+        break;
+
+      if (meta_wayland_dma_buf_fd_readable (fd))
+        continue;
+
+      if (!source)
+        {
+          source =
+            (MetaWaylandDmaBufSource *) g_source_new (&meta_wayland_dma_buf_source_funcs,
+                                                      sizeof (*source));
+          source->buffer = g_object_ref (buffer);
+          source->dispatch = dispatch;
+          source->user_data = user_data;
+        }
+
+      source->fd_tags[i] = g_source_add_unix_fd (&source->base, fd, G_IO_IN);
+    }
+
+  if (!source)
+    return NULL;
+
+  return &source->base;
+}
+
 static void
 buffer_params_create_common (struct wl_client   *client,
                              struct wl_resource *params_resource,
diff --git a/src/wayland/meta-wayland-dma-buf.h b/src/wayland/meta-wayland-dma-buf.h
index 57b1ef68e8..716b8c778b 100644
--- a/src/wayland/meta-wayland-dma-buf.h
+++ b/src/wayland/meta-wayland-dma-buf.h
@@ -57,6 +57,14 @@ meta_wayland_dma_buf_fds_for_wayland_buffer (MetaWaylandBuffer *buffer);
 MetaWaylandDmaBufBuffer *
 meta_wayland_dma_buf_from_buffer (MetaWaylandBuffer *buffer);
 
+typedef void (*MetaWaylandDmaBufSourceDispatch) (MetaWaylandBuffer *buffer,
+                                                 gpointer           user_data);
+
+GSource *
+meta_wayland_dma_buf_create_source (MetaWaylandBuffer               *buffer,
+                                    MetaWaylandDmaBufSourceDispatch  dispatch,
+                                    gpointer                         user_data);
+
 CoglScanout *
 meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandDmaBufBuffer *dma_buf,
                                           CoglOnscreen            *onscreen);
-- 
2.39.1


From 9abe145c5898a245141ea7224d09899dcf455f4b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 25 May 2021 15:51:52 +0200
Subject: [PATCH 06/27] wayland/surface: Discard presentation feedback in
 _state_merge_into

Newly merged state is always from a different surface commit than the
existing state.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-surface.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 351bc589c6..4629ff81e1 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -658,6 +658,11 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
       from->subsurface_placement_ops = NULL;
     }
 
+  /*
+   * A new commit indicates a new content update, so any previous
+   * content update did not go on screen and needs to be discarded.
+   */
+  meta_wayland_surface_state_discard_presentation_feedback (to);
   wl_list_insert_list (&to->presentation_feedback_list,
                        &from->presentation_feedback_list);
   wl_list_init (&from->presentation_feedback_list);
@@ -1025,12 +1030,6 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
     {
       ensure_cached_state (surface);
 
-      /*
-       * A new commit indicates a new content update, so any previous
-       * cached content update did not go on screen and needs to be discarded.
-       */
-      meta_wayland_surface_state_discard_presentation_feedback (surface->cached_state);
-
       meta_wayland_surface_state_merge_into (pending, surface->cached_state);
     }
   else
-- 
2.39.1


From 0c2b166c12faf8a1073964fb4fc4aa2f1a99b6ee Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 25 May 2021 15:55:16 +0200
Subject: [PATCH 07/27] wayland/surface: Move out
 meta_wayland_surface_state_reset calls

From meta_wayland_surface_apply_state / _state_merge_into to their
callers.

Preparation for changing behaviour in the callers, no functional
change intended.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-surface.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 4629ff81e1..7b3a02ad4d 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -666,8 +666,6 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
   wl_list_insert_list (&to->presentation_feedback_list,
                        &from->presentation_feedback_list);
   wl_list_init (&from->presentation_feedback_list);
-
-  meta_wayland_surface_state_reset (from);
 }
 
 static void
@@ -981,8 +979,6 @@ cleanup:
 
   if (surface->role)
     meta_wayland_surface_role_post_apply_state (surface->role, state);
-
-  meta_wayland_surface_state_reset (state);
 }
 
 static void
@@ -998,6 +994,7 @@ meta_wayland_surface_apply_cached_state (MetaWaylandSurface *surface)
 {
   ensure_cached_state (surface);
   meta_wayland_surface_apply_state (surface, surface->cached_state);
+  meta_wayland_surface_state_reset (surface->cached_state);
 }
 
 MetaWaylandSurfaceState *
@@ -1036,6 +1033,8 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
     {
       meta_wayland_surface_apply_state (surface, surface->pending_state);
     }
+
+  meta_wayland_surface_state_reset (pending);
 }
 
 static void
-- 
2.39.1


From 23adbfcc159b7d038734de84f2c7c6606355649a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Sat, 5 Jun 2021 16:46:56 +0200
Subject: [PATCH 08/27] wayland/surface: Rename "should_cache_state" to
 "is_synchronized"

Also remove the stale meta_wayland_surface_is_effectively_synchronized
prototype.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-subsurface.c | 16 +++++-----------
 src/wayland/meta-wayland-surface.c    | 12 ++++++------
 src/wayland/meta-wayland-surface.h    |  6 ++----
 3 files changed, 13 insertions(+), 21 deletions(-)

diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index 6a23c86100..6a50b3299b 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -105,12 +105,6 @@ is_sibling (MetaWaylandSurface *surface,
   return surface != sibling && surface->sub.parent == sibling->sub.parent;
 }
 
-static gboolean
-is_surface_effectively_synchronized (MetaWaylandSurface *surface)
-{
-  return meta_wayland_surface_should_cache_state (surface);
-}
-
 void
 meta_wayland_subsurface_parent_state_applied (MetaWaylandSubsurface *subsurface)
 {
@@ -127,7 +121,7 @@ meta_wayland_subsurface_parent_state_applied (MetaWaylandSubsurface *subsurface)
       surface->sub.pending_pos = FALSE;
     }
 
-  if (is_surface_effectively_synchronized (surface))
+  if (meta_wayland_surface_is_synchronized (surface))
     meta_wayland_surface_apply_cached_state (surface);
 
   meta_wayland_actor_surface_sync_actor_state (actor_surface);
@@ -194,7 +188,7 @@ meta_wayland_subsurface_get_toplevel (MetaWaylandSurfaceRole *surface_role)
 }
 
 static gboolean
-meta_wayland_subsurface_should_cache_state (MetaWaylandSurfaceRole *surface_role)
+meta_wayland_subsurface_is_synchronized (MetaWaylandSurfaceRole *surface_role)
 {
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
@@ -205,7 +199,7 @@ meta_wayland_subsurface_should_cache_state (MetaWaylandSurfaceRole *surface_role
 
   parent = surface->sub.parent;
   if (parent)
-    return meta_wayland_surface_should_cache_state (parent);
+    return meta_wayland_surface_is_synchronized (parent);
 
   return TRUE;
 }
@@ -276,7 +270,7 @@ meta_wayland_subsurface_class_init (MetaWaylandSubsurfaceClass *klass)
 
   surface_role_class->assigned = meta_wayland_subsurface_assigned;
   surface_role_class->get_toplevel = meta_wayland_subsurface_get_toplevel;
-  surface_role_class->should_cache_state = meta_wayland_subsurface_should_cache_state;
+  surface_role_class->is_synchronized = meta_wayland_subsurface_is_synchronized;
   surface_role_class->notify_subsurface_state_changed =
     meta_wayland_subsurface_notify_subsurface_state_changed;
 
@@ -455,7 +449,7 @@ wl_subsurface_set_desync (struct wl_client   *client,
     return;
 
   is_parent_effectively_synchronized =
-    is_surface_effectively_synchronized (surface->sub.parent);
+    meta_wayland_surface_is_synchronized (surface->sub.parent);
 
   if (!is_parent_effectively_synchronized)
     meta_wayland_surface_apply_cached_state (surface);
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 7b3a02ad4d..803a3e1797 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -1023,7 +1023,7 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
    *  2) Its mode changes from synchronized to desynchronized and its parent
    *     surface is in effective desynchronized mode.
    */
-  if (meta_wayland_surface_should_cache_state (surface))
+  if (meta_wayland_surface_is_synchronized (surface))
     {
       ensure_cached_state (surface);
 
@@ -1985,24 +1985,24 @@ meta_wayland_surface_get_window (MetaWaylandSurface *surface)
 }
 
 static gboolean
-meta_wayland_surface_role_should_cache_state (MetaWaylandSurfaceRole *surface_role)
+meta_wayland_surface_role_is_synchronized (MetaWaylandSurfaceRole *surface_role)
 {
   MetaWaylandSurfaceRoleClass *klass;
 
   klass = META_WAYLAND_SURFACE_ROLE_GET_CLASS (surface_role);
-  if (klass->should_cache_state)
-    return klass->should_cache_state (surface_role);
+  if (klass->is_synchronized)
+    return klass->is_synchronized (surface_role);
   else
     return FALSE;
 }
 
 gboolean
-meta_wayland_surface_should_cache_state (MetaWaylandSurface *surface)
+meta_wayland_surface_is_synchronized (MetaWaylandSurface *surface)
 {
   if (!surface->role)
     return FALSE;
 
-  return meta_wayland_surface_role_should_cache_state (surface->role);
+  return meta_wayland_surface_role_is_synchronized (surface->role);
 }
 
 static void
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 757de17d1f..34d7713246 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -63,7 +63,7 @@ struct _MetaWaylandSurfaceRoleClass
   gboolean (*is_on_logical_monitor) (MetaWaylandSurfaceRole *surface_role,
                                      MetaLogicalMonitor     *logical_monitor);
   MetaWaylandSurface * (*get_toplevel) (MetaWaylandSurfaceRole *surface_role);
-  gboolean (*should_cache_state) (MetaWaylandSurfaceRole *surface_role);
+  gboolean (*is_synchronized) (MetaWaylandSurfaceRole *surface_role);
   void (*notify_subsurface_state_changed) (MetaWaylandSurfaceRole *surface_role);
   void (*get_relative_coordinates) (MetaWaylandSurfaceRole *surface_role,
                                     float                   abs_x,
@@ -268,8 +268,6 @@ MetaWaylandSurfaceState *
 
 void                meta_wayland_surface_apply_cached_state (MetaWaylandSurface *surface);
 
-gboolean            meta_wayland_surface_is_effectively_synchronized (MetaWaylandSurface *surface);
-
 gboolean            meta_wayland_surface_assign_role (MetaWaylandSurface *surface,
                                                       GType               role_type,
                                                       const char         *first_property_name,
@@ -307,7 +305,7 @@ MetaWaylandSurface *meta_wayland_surface_get_toplevel (MetaWaylandSurface *surfa
 META_EXPORT_TEST
 MetaWindow *        meta_wayland_surface_get_window (MetaWaylandSurface *surface);
 
-gboolean            meta_wayland_surface_should_cache_state (MetaWaylandSurface *surface);
+gboolean            meta_wayland_surface_is_synchronized (MetaWaylandSurface *surface);
 
 MetaWindow *        meta_wayland_surface_get_toplevel_window (MetaWaylandSurface *surface);
 
-- 
2.39.1


From 3e85b3a6dd6229c26d5561393892f24af935b948 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Thu, 29 Jul 2021 18:14:20 +0200
Subject: [PATCH 09/27] wayland/surface: Prepare for decoupled surface &
 resource lifetimes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Need to deal with surface->resource == NULL and
surface->pending_state == NULL in some places.

v2:
* Avoid expanding conditions to multiple lines.
  (Georges Basile Stavracas Neto)
v3:
* Use a single bailout condition in meta_wayland_client_owns_window as
  well.
v4:
* Remove spare empty line in meta_wayland_surface_apply_state.
  (Robert Mader)
* Add wl_resource_post_error calls in xdg-shell request handlers.
  (Robert Mader)
* Drop checks in functions which can only be called if there's a valid
  resource.
* Drop more checks which are unnecessary due to leaving the
  SURFACE_DESTROY signal emission in wl_surface_destructor later.
v5:
* Move resource = surface->resource assignments to if (!resource) tests.
  (Jonas Ådahl)
v6:
* Fix style issue per check-style.py.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-client.c     |  2 +-
 src/wayland/meta-wayland-surface.c    | 33 +++++++++++++--------
 src/wayland/meta-wayland-tablet-pad.c |  2 +-
 src/wayland/meta-wayland-text-input.c |  2 +-
 src/wayland/meta-wayland-touch.c      |  2 +-
 src/wayland/meta-wayland-viewporter.c | 27 +++++++++++++++---
 src/wayland/meta-wayland-xdg-shell.c  | 41 +++++++++++++++++++++++++--
 src/wayland/meta-window-wayland.c     | 12 ++++++--
 src/wayland/meta-xwayland.c           |  3 +-
 9 files changed, 98 insertions(+), 26 deletions(-)

diff --git a/src/wayland/meta-wayland-client.c b/src/wayland/meta-wayland-client.c
index 69c7b83335..5ca7c6937e 100644
--- a/src/wayland/meta-wayland-client.c
+++ b/src/wayland/meta-wayland-client.c
@@ -297,7 +297,7 @@ meta_wayland_client_owns_window (MetaWaylandClient *client,
   g_return_val_if_fail (client->process_running, FALSE);
 
   surface = window->surface;
-  if (surface == NULL)
+  if (surface == NULL || surface->resource == NULL)
     return FALSE;
 
   return wl_resource_get_client (surface->resource) == client->wayland_client;
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 803a3e1797..3696a2786b 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -769,10 +769,13 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
                                            &error))
             {
               g_warning ("Could not import pending buffer: %s", error->message);
-              wl_resource_post_error (surface->resource, WL_DISPLAY_ERROR_NO_MEMORY,
-                                      "Failed to attach buffer to surface %i: %s",
-                                      wl_resource_get_id (surface->resource),
-                                      error->message);
+              if (surface->resource)
+                {
+                  wl_resource_post_error (surface->resource, WL_DISPLAY_ERROR_NO_MEMORY,
+                                          "Failed to attach buffer to surface %i: %s",
+                                          wl_resource_get_id (surface->resource),
+                                          error->message);
+                }
               g_error_free (error);
               goto cleanup;
             }
@@ -1330,21 +1333,24 @@ static void
 surface_entered_output (MetaWaylandSurface *surface,
                         MetaWaylandOutput *wayland_output)
 {
-  const GList *l;
-
   g_signal_connect (wayland_output, "output-destroyed",
                     G_CALLBACK (handle_output_destroyed),
                     surface);
 
-  for (l = meta_wayland_output_get_resources (wayland_output); l; l = l->next)
+  if (surface->resource)
     {
-      struct wl_resource *resource = l->data;
+      const GList *l;
 
-      if (wl_resource_get_client (resource) !=
-          wl_resource_get_client (surface->resource))
-        continue;
+      for (l = meta_wayland_output_get_resources (wayland_output); l; l = l->next)
+        {
+          struct wl_resource *resource = l->data;
+
+          if (wl_resource_get_client (resource) !=
+              wl_resource_get_client (surface->resource))
+            continue;
 
-      wl_surface_send_enter (surface->resource, resource);
+          wl_surface_send_enter (surface->resource, resource);
+        }
     }
 
   g_signal_connect (wayland_output, "output-bound",
@@ -1366,6 +1372,9 @@ surface_left_output (MetaWaylandSurface *surface,
                                         G_CALLBACK (handle_output_bound),
                                         surface);
 
+  if (!surface->resource)
+    return;
+
   for (l = meta_wayland_output_get_resources (wayland_output); l; l = l->next)
     {
       struct wl_resource *resource = l->data;
diff --git a/src/wayland/meta-wayland-tablet-pad.c b/src/wayland/meta-wayland-tablet-pad.c
index fc108b7959..92c36fa802 100644
--- a/src/wayland/meta-wayland-tablet-pad.c
+++ b/src/wayland/meta-wayland-tablet-pad.c
@@ -466,7 +466,7 @@ meta_wayland_tablet_pad_set_focus (MetaWaylandTabletPad *pad,
   tablet = meta_wayland_tablet_seat_lookup_paired_tablet (pad->tablet_seat,
                                                           pad);
 
-  if (tablet != NULL && surface != NULL)
+  if (tablet != NULL && surface != NULL && surface->resource != NULL)
     {
       struct wl_client *client;
 
diff --git a/src/wayland/meta-wayland-text-input.c b/src/wayland/meta-wayland-text-input.c
index 1cfeb35777..c12fe2024a 100644
--- a/src/wayland/meta-wayland-text-input.c
+++ b/src/wayland/meta-wayland-text-input.c
@@ -371,7 +371,7 @@ meta_wayland_text_input_set_focus (MetaWaylandTextInput *text_input,
       text_input->surface = NULL;
     }
 
-  if (surface)
+  if (surface && surface->resource)
     {
       struct wl_resource *focus_surface_resource;
 
diff --git a/src/wayland/meta-wayland-touch.c b/src/wayland/meta-wayland-touch.c
index 5824e229d6..6d45b4b7b3 100644
--- a/src/wayland/meta-wayland-touch.c
+++ b/src/wayland/meta-wayland-touch.c
@@ -227,7 +227,7 @@ meta_wayland_touch_update (MetaWaylandTouch   *touch,
       if (META_IS_SURFACE_ACTOR_WAYLAND (actor))
         surface = meta_surface_actor_wayland_get_surface (META_SURFACE_ACTOR_WAYLAND (actor));
 
-      if (!surface)
+      if (!surface || !surface->resource)
         return;
 
       touch_info = touch_get_info (touch, sequence, TRUE);
diff --git a/src/wayland/meta-wayland-viewporter.c b/src/wayland/meta-wayland-viewporter.c
index 619f3177c1..85b1c77edd 100644
--- a/src/wayland/meta-wayland-viewporter.c
+++ b/src/wayland/meta-wayland-viewporter.c
@@ -46,10 +46,13 @@ wp_viewport_destructor (struct wl_resource *resource)
   g_clear_signal_handler (&surface->viewport.destroy_handler_id, surface);
 
   pending = meta_wayland_surface_get_pending_state (surface);
-  pending->viewport_src_rect.size.width = -1;
-  pending->viewport_dst_width = -1;
-  pending->has_new_viewport_src_rect = TRUE;
-  pending->has_new_viewport_dst_size = TRUE;
+  if (pending)
+    {
+      pending->viewport_src_rect.size.width = -1;
+      pending->viewport_dst_width = -1;
+      pending->has_new_viewport_src_rect = TRUE;
+      pending->has_new_viewport_dst_size = TRUE;
+    }
 
   surface->viewport.resource = NULL;
 }
@@ -103,6 +106,14 @@ wp_viewport_set_source (struct wl_client   *client,
       MetaWaylandSurfaceState *pending;
 
       pending = meta_wayland_surface_get_pending_state (surface);
+      if (!pending)
+        {
+          wl_resource_post_error (resource,
+                                  WP_VIEWPORT_ERROR_NO_SURFACE,
+                                  "wl_surface for this viewport no longer exists");
+          return;
+        }
+
       pending->viewport_src_rect.origin.x = new_x;
       pending->viewport_src_rect.origin.y = new_y;
       pending->viewport_src_rect.size.width = new_width;
@@ -142,6 +153,14 @@ wp_viewport_set_destination (struct wl_client   *client,
       MetaWaylandSurfaceState *pending;
 
       pending = meta_wayland_surface_get_pending_state (surface);
+      if (!pending)
+        {
+          wl_resource_post_error (resource,
+                                  WP_VIEWPORT_ERROR_NO_SURFACE,
+                                  "wl_surface for this viewport no longer exists");
+          return;
+        }
+
       pending->viewport_dst_width = dst_width;
       pending->viewport_dst_height = dst_height;
       pending->has_new_viewport_dst_size = TRUE;
diff --git a/src/wayland/meta-wayland-xdg-shell.c b/src/wayland/meta-wayland-xdg-shell.c
index 485aa01f5e..bb68e5ecb5 100644
--- a/src/wayland/meta-wayland-xdg-shell.c
+++ b/src/wayland/meta-wayland-xdg-shell.c
@@ -391,6 +391,14 @@ xdg_toplevel_set_max_size (struct wl_client   *client,
 
 
   pending = meta_wayland_surface_get_pending_state (surface);
+  if (!pending)
+    {
+      wl_resource_post_error (resource,
+                              XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
+                              "underlying wl_surface already destroyed");
+      return;
+    }
+
   pending->has_new_max_size = TRUE;
   pending->new_max_width = width;
   pending->new_max_height = height;
@@ -416,6 +424,14 @@ xdg_toplevel_set_min_size (struct wl_client   *client,
 
 
   pending = meta_wayland_surface_get_pending_state (surface);
+  if (!pending)
+    {
+      wl_resource_post_error (resource,
+                              XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
+                              "underlying wl_surface already destroyed");
+      return;
+    }
+
   pending->has_new_min_size = TRUE;
   pending->new_min_width = width;
   pending->new_min_height = height;
@@ -873,9 +889,12 @@ meta_wayland_xdg_toplevel_post_apply_state (MetaWaylandSurfaceRole  *surface_rol
         }
       else
         {
-          wl_resource_post_error (surface->resource,
-                                  XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
-                                  "Invalid min/max size");
+          if (surface->resource)
+            {
+              wl_resource_post_error (surface->resource,
+                                      XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
+                                      "Invalid min/max size");
+            }
         }
     }
 }
@@ -1556,6 +1575,14 @@ xdg_surface_set_window_geometry (struct wl_client   *client,
     }
 
   pending = meta_wayland_surface_get_pending_state (surface);
+  if (!pending)
+    {
+      wl_resource_post_error (resource,
+                              XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
+                              "underlying wl_surface already destroyed");
+      return;
+    }
+
   pending->has_new_geometry = TRUE;
   pending->new_geometry.x = x;
   pending->new_geometry.y = y;
@@ -1572,6 +1599,14 @@ xdg_surface_ack_configure (struct wl_client   *client,
   MetaWaylandSurfaceState *pending;
 
   pending = meta_wayland_surface_get_pending_state (surface);
+  if (!pending)
+    {
+      wl_resource_post_error (resource,
+                              XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
+                              "underlying wl_surface already destroyed");
+      return;
+    }
+
   pending->has_acked_configure_serial = TRUE;
   pending->acked_configure_serial = serial;
 }
diff --git a/src/wayland/meta-window-wayland.c b/src/wayland/meta-window-wayland.c
index b63049e7df..bdbb818a68 100644
--- a/src/wayland/meta-window-wayland.c
+++ b/src/wayland/meta-window-wayland.c
@@ -145,7 +145,11 @@ static void
 meta_window_wayland_kill (MetaWindow *window)
 {
   MetaWaylandSurface *surface = window->surface;
-  struct wl_resource *resource = surface->resource;
+  struct wl_resource *resource;
+
+  resource = surface->resource;
+  if (!resource)
+    return;
 
   /* Send the client an unrecoverable error to kill the client. */
   wl_resource_post_error (resource,
@@ -643,9 +647,13 @@ static pid_t
 meta_window_wayland_get_client_pid (MetaWindow *window)
 {
   MetaWaylandSurface *surface = window->surface;
-  struct wl_resource *resource = surface->resource;
+  struct wl_resource *resource;
   pid_t pid;
 
+  resource = surface->resource;
+  if (!resource)
+    return 0;
+
   wl_client_get_credentials (wl_resource_get_client (resource), &pid, NULL, NULL);
   return pid;
 }
diff --git a/src/wayland/meta-xwayland.c b/src/wayland/meta-xwayland.c
index c9d94b2e38..44229eac08 100644
--- a/src/wayland/meta-xwayland.c
+++ b/src/wayland/meta-xwayland.c
@@ -137,7 +137,8 @@ meta_xwayland_is_xwayland_surface (MetaWaylandSurface *surface)
   MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
   MetaXWaylandManager *manager = &compositor->xwayland_manager;
 
-  return wl_resource_get_client (surface->resource) == manager->client;
+  return surface->resource != NULL &&
+         wl_resource_get_client (surface->resource) == manager->client;
 }
 
 static gboolean
-- 
2.39.1


From 45fd7ae34c89e0c103c7e5477d99791fb7cfeef4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 10 Jun 2022 17:23:08 +0200
Subject: [PATCH 10/27] wayland: Add transaction skeleton
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

v2:
* Use single hash table with struct which will contain all kinds of
  state handled by a transaction.
v3:
* Add meta_wayland_transaction_destroy.
v4 (Georges Basile Stavracas Neto)
* Fix struct _MetaWaylandTransaction(Entry) formatting.
* Explicitly test against NULL.
* Use gpointer insteadof void * for
  meta_wayland_transaction_entry_destroy.
v5: (Robert Mader)
* Use for loop in is_ancestor.
* Include meta-wayland-transaction.h first in
  meta-wayland-transaction.c.
v6:
* Use g_autofree & g_clear_object.
v7: (Jonas Ådahl)
* Rename meta_wayland_transaction_entry_destroy to
  meta_wayland_transaction_entry_free.
* Drop g_autofree use from meta_wayland_transaction_entry_free again.
* Make meta_wayland_transaction_entry_free take a
  MetaWaylandTransactionEntry pointer.
* Rename meta_wayland_transaction_destroy to
  meta_wayland_transaction_free.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/meson.build                        |   2 +
 src/wayland/meta-wayland-surface.c     |   2 +-
 src/wayland/meta-wayland-surface.h     |   3 +
 src/wayland/meta-wayland-transaction.c | 186 +++++++++++++++++++++++++
 src/wayland/meta-wayland-transaction.h |  35 +++++
 src/wayland/meta-wayland-types.h       |   2 +
 6 files changed, 229 insertions(+), 1 deletion(-)
 create mode 100644 src/wayland/meta-wayland-transaction.c
 create mode 100644 src/wayland/meta-wayland-transaction.h

diff --git a/src/meson.build b/src/meson.build
index 6790efa161..84320adbbb 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -657,6 +657,8 @@ if have_wayland
     'wayland/meta-wayland-text-input.h',
     'wayland/meta-wayland-touch.c',
     'wayland/meta-wayland-touch.h',
+    'wayland/meta-wayland-transaction.c',
+    'wayland/meta-wayland-transaction.h',
     'wayland/meta-wayland-types.h',
     'wayland/meta-wayland-versions.h',
     'wayland/meta-wayland-viewporter.c',
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 3696a2786b..adc8ba836f 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -713,7 +713,7 @@ meta_wayland_surface_discard_presentation_feedback (MetaWaylandSurface *surface)
     }
 }
 
-static void
+void
 meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
                                   MetaWaylandSurfaceState *state)
 {
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 34d7713246..e0f7544c54 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -263,6 +263,9 @@ MetaWaylandSurface *meta_wayland_surface_create (MetaWaylandCompositor *composit
                                                  struct wl_resource    *compositor_resource,
                                                  guint32                id);
 
+void                meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
+                                                      MetaWaylandSurfaceState *state);
+
 MetaWaylandSurfaceState *
                     meta_wayland_surface_get_pending_state (MetaWaylandSurface *surface);
 
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
new file mode 100644
index 0000000000..37af40fa9b
--- /dev/null
+++ b/src/wayland/meta-wayland-transaction.c
@@ -0,0 +1,186 @@
+/*
+ * Wayland Transaction Support
+ *
+ * Copyright (C) 2021 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include "wayland/meta-wayland-transaction.h"
+
+#include "wayland/meta-wayland-subsurface.h"
+
+struct _MetaWaylandTransaction
+{
+  GHashTable *entries;
+};
+
+typedef struct _MetaWaylandTransactionEntry
+{
+  MetaWaylandSurfaceState *state;
+} MetaWaylandTransactionEntry;
+
+static MetaWaylandTransactionEntry *
+meta_wayland_transaction_get_entry (MetaWaylandTransaction *transaction,
+                                    MetaWaylandSurface     *surface)
+{
+  return g_hash_table_lookup (transaction->entries, surface);
+}
+
+static void
+meta_wayland_transaction_sync_child_states (MetaWaylandSurface *surface)
+{
+  MetaWaylandSurface *subsurface_surface;
+
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+    {
+      MetaWaylandSubsurface *subsurface;
+      MetaWaylandActorSurface *actor_surface;
+
+      subsurface = META_WAYLAND_SUBSURFACE (subsurface_surface->role);
+      actor_surface = META_WAYLAND_ACTOR_SURFACE (subsurface);
+      meta_wayland_actor_surface_sync_actor_state (actor_surface);
+    }
+}
+
+static gboolean
+is_ancestor (MetaWaylandSurface *candidate,
+             MetaWaylandSurface *reference)
+{
+  MetaWaylandSurface *ancestor;
+
+  for (ancestor = reference->sub.parent; ancestor; ancestor = ancestor->sub.parent)
+    {
+      if (ancestor == candidate)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static int
+meta_wayland_transaction_compare (const void *key1,
+                                  const void *key2)
+{
+  MetaWaylandSurface *surface1 = *(MetaWaylandSurface **) key1;
+  MetaWaylandSurface *surface2 = *(MetaWaylandSurface **) key2;
+
+  /* Order of siblings doesn't matter */
+  if (surface1->sub.parent == surface2->sub.parent)
+    return 0;
+
+  /* Ancestor surfaces come before descendant surfaces */
+  if (is_ancestor (surface1, surface2))
+    return 1;
+
+  if (is_ancestor (surface2, surface1))
+    return -1;
+
+  /*
+   * Order unrelated surfaces by their toplevel surface pointer values, to
+   * prevent unrelated surfaces from getting mixed between siblings
+   */
+  return (meta_wayland_surface_get_toplevel (surface1) <
+          meta_wayland_surface_get_toplevel (surface2)) ? -1 : 1;
+}
+
+void
+meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
+{
+  g_autofree MetaWaylandSurface **surfaces = NULL;
+  unsigned int num_surfaces;
+  int i;
+
+  surfaces = (MetaWaylandSurface **)
+    g_hash_table_get_keys_as_array (transaction->entries, &num_surfaces);
+
+  /* Sort surfaces from ancestors to descendants */
+  qsort (surfaces, num_surfaces, sizeof (MetaWaylandSurface *),
+         meta_wayland_transaction_compare);
+
+  /* Apply states from ancestors to descendants */
+  for (i = 0; i < num_surfaces; i++)
+    {
+      MetaWaylandSurface *surface = surfaces[i];
+      MetaWaylandTransactionEntry *entry;
+
+      entry = meta_wayland_transaction_get_entry (transaction, surface);
+      meta_wayland_surface_apply_state (surface, entry->state);
+    }
+
+  /* Synchronize child states from descendants to ancestors */
+  for (i = num_surfaces - 1; i >= 0; i--)
+    meta_wayland_transaction_sync_child_states (surfaces[i]);
+
+  meta_wayland_transaction_free (transaction);
+}
+
+static MetaWaylandTransactionEntry *
+meta_wayland_transaction_ensure_entry (MetaWaylandTransaction *transaction,
+                                       MetaWaylandSurface     *surface)
+{
+  MetaWaylandTransactionEntry *entry;
+
+  entry = meta_wayland_transaction_get_entry (transaction, surface);
+  if (entry)
+    return entry;
+
+  entry = g_new0 (MetaWaylandTransactionEntry, 1);
+  g_hash_table_insert (transaction->entries, surface, entry);
+
+  return entry;
+}
+
+void
+meta_wayland_transaction_add_state (MetaWaylandTransaction  *transaction,
+                                    MetaWaylandSurface      *surface,
+                                    MetaWaylandSurfaceState *state)
+{
+  MetaWaylandTransactionEntry *entry;
+
+  entry = meta_wayland_transaction_ensure_entry (transaction, surface);
+  g_assert (!entry->state);
+  entry->state = state;
+}
+
+static void
+meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
+{
+  g_clear_object (&entry->state);
+  g_free (entry);
+}
+
+MetaWaylandTransaction *
+meta_wayland_transaction_new (void)
+{
+  MetaWaylandTransaction *transaction;
+
+  transaction = g_new0 (MetaWaylandTransaction, 1);
+
+  transaction->entries = g_hash_table_new_full (NULL, NULL, NULL,
+                                                (GDestroyNotify) meta_wayland_transaction_entry_free);
+
+  return transaction;
+}
+
+void
+meta_wayland_transaction_free (MetaWaylandTransaction *transaction)
+{
+  g_hash_table_destroy (transaction->entries);
+  g_free (transaction);
+}
diff --git a/src/wayland/meta-wayland-transaction.h b/src/wayland/meta-wayland-transaction.h
new file mode 100644
index 0000000000..62c0f388db
--- /dev/null
+++ b/src/wayland/meta-wayland-transaction.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2021 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef META_WAYLAND_TRANSACTION_H
+#define META_WAYLAND_TRANSACTION_H
+
+#include "wayland/meta-wayland-types.h"
+
+void meta_wayland_transaction_commit (MetaWaylandTransaction *transaction);
+
+void meta_wayland_transaction_add_state (MetaWaylandTransaction  *transaction,
+                                         MetaWaylandSurface      *surface,
+                                         MetaWaylandSurfaceState *state);
+
+MetaWaylandTransaction *meta_wayland_transaction_new (void);
+
+void meta_wayland_transaction_free (MetaWaylandTransaction *transaction);
+
+#endif
diff --git a/src/wayland/meta-wayland-types.h b/src/wayland/meta-wayland-types.h
index 2df2b5e2f8..c4db05b61e 100644
--- a/src/wayland/meta-wayland-types.h
+++ b/src/wayland/meta-wayland-types.h
@@ -54,6 +54,8 @@ typedef struct _MetaWaylandRegion MetaWaylandRegion;
 typedef struct _MetaWaylandSurface MetaWaylandSurface;
 typedef struct _MetaWaylandSurfaceState MetaWaylandSurfaceState;
 
+typedef struct _MetaWaylandTransaction MetaWaylandTransaction;
+
 typedef struct _MetaWaylandOutput MetaWaylandOutput;
 
 typedef struct _MetaWaylandWindowConfiguration MetaWaylandWindowConfiguration;
-- 
2.39.1


From ea9f1547b92387ac1e7894cb28cdf50399b01280 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Sun, 30 May 2021 15:00:13 +0200
Subject: [PATCH 11/27] wayland/surface: Make sure transactions are applied in
 consistent order
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If multiple transactions have entries for the same surface, they are
applied in the same order as they were committed. Otherwise, they can
be applied in any order.

This is preparation for following changes, transactions are still
applied as soon as they're committed.

v2:
* Move GQueue for transactions to MetaWaylandCompositor (Jonas Ådahl)
v3
* Say "entry for" instead of "state for", since there can be transaction
  entries with no state (for surfaces which are getting destroyed).
v4:
* Use a hash table to keep track of all candidate transactions which
  might be newly ready to be applied.
* Use clearer function / variable names.
v5:
* Use custom single-linked list instead of hash table for candidate
  transactions, ordered by the transaction commit sequence number, so
  that they're attempted to be applied in the same order as they were
  committed.
* Rename transaction->queue to transaction->committed_queue, and
  simplify its handling.
v6: (Carlos Garnacho)
* Add spaces between type casts and values.
* Use (gpointer *) instead of (void**).
v7: (Jonas Ådahl)
* Use G_MAXSIZE instead of ULONG_MAX.
* Fix indentation of meta_wayland_transaction_apply &
  meta_wayland_transaction_maybe_apply_one parameters.
* Refactor find_next_transaction_for_surface & ensure_next_candidate
  helper functions out of meta_wayland_transaction_apply.
* Refactor has_unapplied_dependencies helper function out of
  meta_wayland_transaction_maybe_apply_one.
* Make while (TRUE) loop in meta_wayland_transaction_maybe_apply
  consistent with general usage.
* Drop unused value local from meta_wayland_transaction_commit.
* Store pointer to compositor object in transactions, instead of
  pointer to the queue of committed transactions.
* Drop tautological g_assert from meta_wayland_transaction_apply. (me)

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-private.h     |   6 +
 src/wayland/meta-wayland-surface.h     |   7 +
 src/wayland/meta-wayland-transaction.c | 174 ++++++++++++++++++++++++-
 src/wayland/meta-wayland-transaction.h |   6 +-
 src/wayland/meta-wayland.c             |  10 ++
 src/wayland/meta-wayland.h             |   2 +
 6 files changed, 201 insertions(+), 4 deletions(-)

diff --git a/src/wayland/meta-wayland-private.h b/src/wayland/meta-wayland-private.h
index dc4dba4b43..c9a236a2e7 100644
--- a/src/wayland/meta-wayland-private.h
+++ b/src/wayland/meta-wayland-private.h
@@ -100,6 +100,12 @@ struct _MetaWaylandCompositor
 
   MetaWaylandPresentationTime presentation_time;
   MetaWaylandDmaBufManager *dma_buf_manager;
+
+  /*
+   * Queue of transactions which have been committed but not applied yet, in the
+   * order they were committed.
+   */
+  GQueue committed_transactions;
 };
 
 #define META_TYPE_WAYLAND_COMPOSITOR (meta_wayland_compositor_get_type ())
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index e0f7544c54..56bcbb1893 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -254,6 +254,13 @@ struct _MetaWaylandSurface
 
   /* dma-buf feedback */
   MetaCrtc *scanout_candidate;
+
+  /* Transactions */
+  struct {
+    /* First & last committed transaction which has an entry for this surface */
+    MetaWaylandTransaction *first_committed;
+    MetaWaylandTransaction *last_committed;
+  } transaction;
 };
 
 void                meta_wayland_shell_init     (MetaWaylandCompositor *compositor);
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 37af40fa9b..96a0b18bc4 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -23,10 +23,18 @@
 
 #include "wayland/meta-wayland-transaction.h"
 
+#include "wayland/meta-wayland.h"
 #include "wayland/meta-wayland-subsurface.h"
 
+#define META_WAYLAND_TRANSACTION_NONE ((void *)(uintptr_t) G_MAXSIZE)
+
 struct _MetaWaylandTransaction
 {
+  GList node;
+  MetaWaylandCompositor *compositor;
+  MetaWaylandTransaction *next_candidate;
+  uint64_t committed_sequence;
+
   GHashTable *entries;
 };
 
@@ -99,8 +107,46 @@ meta_wayland_transaction_compare (const void *key1,
           meta_wayland_surface_get_toplevel (surface2)) ? -1 : 1;
 }
 
-void
-meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
+static MetaWaylandTransaction *
+find_next_transaction_for_surface (MetaWaylandTransaction *transaction,
+                                   MetaWaylandSurface     *surface)
+{
+  GList *node;
+
+  for (node = transaction->node.next; node; node = node->next)
+    {
+      MetaWaylandTransaction *next = node->data;
+
+      if (surface->transaction.last_committed == next ||
+          g_hash_table_contains (next->entries, surface))
+        return next;
+    }
+
+  return NULL;
+}
+
+static void
+ensure_next_candidate (MetaWaylandTransaction  *transaction,
+                       MetaWaylandTransaction **first_candidate)
+{
+  MetaWaylandTransaction **candidate;
+
+  if (transaction->next_candidate)
+    return;
+
+  candidate = first_candidate;
+  while (*candidate != META_WAYLAND_TRANSACTION_NONE &&
+         (*candidate)->committed_sequence <
+         transaction->committed_sequence)
+    candidate = &(*candidate)->next_candidate;
+
+  transaction->next_candidate = *candidate;
+  *candidate = transaction;
+}
+
+static void
+meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
+                                MetaWaylandTransaction **first_candidate)
 {
   g_autofree MetaWaylandSurface **surfaces = NULL;
   unsigned int num_surfaces;
@@ -121,6 +167,23 @@ meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
 
       entry = meta_wayland_transaction_get_entry (transaction, surface);
       meta_wayland_surface_apply_state (surface, entry->state);
+
+      if (surface->transaction.last_committed == transaction)
+        {
+          surface->transaction.first_committed = NULL;
+          surface->transaction.last_committed = NULL;
+        }
+      else
+        {
+          MetaWaylandTransaction *next_transaction;
+
+          next_transaction = find_next_transaction_for_surface (transaction, surface);
+          if (next_transaction)
+            {
+              surface->transaction.first_committed = next_transaction;
+              ensure_next_candidate (next_transaction, first_candidate);
+            }
+        }
     }
 
   /* Synchronize child states from descendants to ancestors */
@@ -130,6 +193,81 @@ meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
   meta_wayland_transaction_free (transaction);
 }
 
+static gboolean
+has_unapplied_dependencies (MetaWaylandTransaction *transaction)
+{
+  GHashTableIter iter;
+  MetaWaylandSurface *surface;
+
+  g_hash_table_iter_init (&iter, transaction->entries);
+  while (g_hash_table_iter_next (&iter, (gpointer *) &surface, NULL))
+    {
+      if (surface->transaction.first_committed != transaction)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static void
+meta_wayland_transaction_maybe_apply_one (MetaWaylandTransaction  *transaction,
+                                          MetaWaylandTransaction **first_candidate)
+{
+  if (has_unapplied_dependencies (transaction))
+    return;
+
+  meta_wayland_transaction_apply (transaction, first_candidate);
+}
+
+static void
+meta_wayland_transaction_maybe_apply (MetaWaylandTransaction *transaction)
+{
+  MetaWaylandTransaction *first_candidate = META_WAYLAND_TRANSACTION_NONE;
+
+  while (TRUE)
+    {
+      meta_wayland_transaction_maybe_apply_one (transaction, &first_candidate);
+
+      if (first_candidate == META_WAYLAND_TRANSACTION_NONE)
+        return;
+
+      transaction = first_candidate;
+      first_candidate = transaction->next_candidate;
+      transaction->next_candidate = NULL;
+    }
+}
+
+void
+meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
+{
+  static uint64_t committed_sequence;
+  GQueue *committed_queue;
+  gboolean maybe_apply = TRUE;
+  GHashTableIter iter;
+  MetaWaylandSurface *surface;
+
+  transaction->committed_sequence = ++committed_sequence;
+  transaction->node.data = transaction;
+
+  committed_queue =
+    meta_wayland_compositor_get_committed_transactions (transaction->compositor);
+  g_queue_push_tail_link (committed_queue, &transaction->node);
+
+  g_hash_table_iter_init (&iter, transaction->entries);
+  while (g_hash_table_iter_next (&iter, (gpointer *) &surface, NULL))
+    {
+      surface->transaction.last_committed = transaction;
+
+      if (!surface->transaction.first_committed)
+        surface->transaction.first_committed = transaction;
+      else
+        maybe_apply = FALSE;
+    }
+
+  if (maybe_apply)
+    meta_wayland_transaction_maybe_apply (transaction);
+}
+
 static MetaWaylandTransactionEntry *
 meta_wayland_transaction_ensure_entry (MetaWaylandTransaction *transaction,
                                        MetaWaylandSurface     *surface)
@@ -166,12 +304,13 @@ meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
 }
 
 MetaWaylandTransaction *
-meta_wayland_transaction_new (void)
+meta_wayland_transaction_new (MetaWaylandCompositor *compositor)
 {
   MetaWaylandTransaction *transaction;
 
   transaction = g_new0 (MetaWaylandTransaction, 1);
 
+  transaction->compositor = compositor;
   transaction->entries = g_hash_table_new_full (NULL, NULL, NULL,
                                                 (GDestroyNotify) meta_wayland_transaction_entry_free);
 
@@ -181,6 +320,35 @@ meta_wayland_transaction_new (void)
 void
 meta_wayland_transaction_free (MetaWaylandTransaction *transaction)
 {
+  if (transaction->node.data)
+    {
+      GQueue *committed_queue =
+        meta_wayland_compositor_get_committed_transactions (transaction->compositor);
+
+      g_queue_unlink (committed_queue, &transaction->node);
+    }
+
   g_hash_table_destroy (transaction->entries);
   g_free (transaction);
 }
+
+void
+meta_wayland_transaction_finalize (MetaWaylandCompositor *compositor)
+{
+  GQueue *transactions;
+  MetaWaylandTransaction *transaction;
+
+  transactions = meta_wayland_compositor_get_committed_transactions (compositor);
+
+  while ((transaction = g_queue_pop_head (transactions)))
+    meta_wayland_transaction_free (transaction);
+}
+
+void
+meta_wayland_transaction_init (MetaWaylandCompositor *compositor)
+{
+  GQueue *transactions;
+
+  transactions = meta_wayland_compositor_get_committed_transactions (compositor);
+  g_queue_init (transactions);
+}
diff --git a/src/wayland/meta-wayland-transaction.h b/src/wayland/meta-wayland-transaction.h
index 62c0f388db..230548c193 100644
--- a/src/wayland/meta-wayland-transaction.h
+++ b/src/wayland/meta-wayland-transaction.h
@@ -28,8 +28,12 @@ void meta_wayland_transaction_add_state (MetaWaylandTransaction  *transaction,
                                          MetaWaylandSurface      *surface,
                                          MetaWaylandSurfaceState *state);
 
-MetaWaylandTransaction *meta_wayland_transaction_new (void);
+MetaWaylandTransaction *meta_wayland_transaction_new (MetaWaylandCompositor *compositor);
 
 void meta_wayland_transaction_free (MetaWaylandTransaction *transaction);
 
+void meta_wayland_transaction_finalize (MetaWaylandCompositor *compositor);
+
+void meta_wayland_transaction_init (MetaWaylandCompositor *compositor);
+
 #endif
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index b3888650a1..854cfe4be7 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -46,6 +46,7 @@
 #include "wayland/meta-wayland-seat.h"
 #include "wayland/meta-wayland-subsurface.h"
 #include "wayland/meta-wayland-tablet-manager.h"
+#include "wayland/meta-wayland-transaction.h"
 #include "wayland/meta-wayland-xdg-foreign.h"
 #include "wayland/meta-xwayland-grab-keyboard.h"
 #include "wayland/meta-xwayland-private.h"
@@ -369,6 +370,12 @@ meta_wayland_compositor_remove_presentation_feedback_surface (MetaWaylandComposi
     g_list_remove (compositor->presentation_time.feedback_surfaces, surface);
 }
 
+GQueue *
+meta_wayland_compositor_get_committed_transactions (MetaWaylandCompositor *compositor)
+{
+  return &compositor->committed_transactions;
+}
+
 static void
 set_gnome_env (const char *name,
 	       const char *value)
@@ -456,6 +463,8 @@ meta_wayland_compositor_finalize (GObject *object)
   g_signal_handlers_disconnect_by_func (stage, on_after_update, compositor);
   g_signal_handlers_disconnect_by_func (stage, on_presented, compositor);
 
+  meta_wayland_transaction_finalize (compositor);
+
   g_clear_object (&compositor->dma_buf_manager);
 
   g_clear_pointer (&compositor->seat, meta_wayland_seat_free);
@@ -631,6 +640,7 @@ meta_wayland_compositor_new (MetaContext *context)
   meta_wayland_text_input_init (compositor);
   meta_wayland_init_presentation_time (compositor);
   meta_wayland_activation_init (compositor);
+  meta_wayland_transaction_init (compositor);
 
   /* Xwayland specific protocol, needs to be filtered out for all other clients */
   if (meta_xwayland_grab_keyboard_init (compositor))
diff --git a/src/wayland/meta-wayland.h b/src/wayland/meta-wayland.h
index 901faaed12..36b7f40ec3 100644
--- a/src/wayland/meta-wayland.h
+++ b/src/wayland/meta-wayland.h
@@ -70,6 +70,8 @@ void                    meta_wayland_compositor_add_presentation_feedback_surfac
 void                    meta_wayland_compositor_remove_presentation_feedback_surface (MetaWaylandCompositor *compositor,
                                                                                       MetaWaylandSurface    *surface);
 
+GQueue                 *meta_wayland_compositor_get_committed_transactions (MetaWaylandCompositor *compositor);
+
 META_EXPORT_TEST
 const char             *meta_wayland_get_wayland_display_name   (MetaWaylandCompositor *compositor);
 
-- 
2.39.1


From 1dcf35c6ce717a5ca77af30b11fe0902e850a679 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 28 May 2021 12:39:48 +0200
Subject: [PATCH 12/27] wayland/surface: Use transactions for applying
 committed states
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

A transaction contains the committed state for a surface, plus any
cached state for synchronized subsurfaces.

v2:
* Handle sub-surface positions separately from surface states.
v3:
* Sync child states only for surfaces with state in the transaction.
v4: (Jonas Ådahl)
* Drop unnecessary g_object_new call from wl_subsurface_set_desync. (me)
* Fix indentation & formatting in meta_wayland_surface_commit.
* Add meta_wayland_surface_state_new helper function.
* Fix alignment of meta_wayland_transaction_apply_subsurface_position
  parameters.
* Add curly braces around meta_wayland_transaction_sync_child_states
  call in meta_wayland_transaction_apply.
v5:
* Make meta_wayland_surface_state_new an inline function.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-subsurface.c  | 31 +++-------
 src/wayland/meta-wayland-subsurface.h  |  2 -
 src/wayland/meta-wayland-surface.c     | 54 +++++++----------
 src/wayland/meta-wayland-surface.h     |  9 ++-
 src/wayland/meta-wayland-transaction.c | 80 +++++++++++++++++++++++++-
 src/wayland/meta-wayland-transaction.h |  9 +++
 6 files changed, 125 insertions(+), 60 deletions(-)

diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index 6a50b3299b..ba86d62060 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -28,6 +28,7 @@
 #include "wayland/meta-wayland-actor-surface.h"
 #include "wayland/meta-wayland-buffer.h"
 #include "wayland/meta-wayland-surface.h"
+#include "wayland/meta-wayland-transaction.h"
 #include "wayland/meta-window-wayland.h"
 
 struct _MetaWaylandSubsurface
@@ -105,28 +106,6 @@ is_sibling (MetaWaylandSurface *surface,
   return surface != sibling && surface->sub.parent == sibling->sub.parent;
 }
 
-void
-meta_wayland_subsurface_parent_state_applied (MetaWaylandSubsurface *subsurface)
-{
-  MetaWaylandSurfaceRole *surface_role = META_WAYLAND_SURFACE_ROLE (subsurface);
-  MetaWaylandActorSurface *actor_surface =
-    META_WAYLAND_ACTOR_SURFACE (subsurface);
-  MetaWaylandSurface *surface =
-    meta_wayland_surface_role_get_surface (surface_role);
-
-  if (surface->sub.pending_pos)
-    {
-      surface->sub.x = surface->sub.pending_x;
-      surface->sub.y = surface->sub.pending_y;
-      surface->sub.pending_pos = FALSE;
-    }
-
-  if (meta_wayland_surface_is_synchronized (surface))
-    meta_wayland_surface_apply_cached_state (surface);
-
-  meta_wayland_actor_surface_sync_actor_state (actor_surface);
-}
-
 void
 meta_wayland_subsurface_union_geometry (MetaWaylandSubsurface *subsurface,
                                         int                    parent_x,
@@ -452,7 +431,13 @@ wl_subsurface_set_desync (struct wl_client   *client,
     meta_wayland_surface_is_synchronized (surface->sub.parent);
 
   if (!is_parent_effectively_synchronized)
-    meta_wayland_surface_apply_cached_state (surface);
+    {
+      MetaWaylandTransaction *transaction;
+
+      transaction = meta_wayland_transaction_new (surface->compositor);
+      meta_wayland_transaction_add_cached_states (transaction, surface);
+      meta_wayland_transaction_commit (transaction);
+    }
 
   surface->sub.synchronous = FALSE;
 }
diff --git a/src/wayland/meta-wayland-subsurface.h b/src/wayland/meta-wayland-subsurface.h
index 45dbf86269..5fa2999db4 100644
--- a/src/wayland/meta-wayland-subsurface.h
+++ b/src/wayland/meta-wayland-subsurface.h
@@ -44,8 +44,6 @@ typedef struct
   struct wl_listener sibling_destroy_listener;
 } MetaWaylandSubsurfacePlacementOp;
 
-void meta_wayland_subsurface_parent_state_applied (MetaWaylandSubsurface *subsurface);
-
 void meta_wayland_subsurface_union_geometry (MetaWaylandSubsurface *subsurface,
                                              int                    parent_x,
                                              int                    parent_y,
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index adc8ba836f..852bbed99b 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -48,6 +48,7 @@
 #include "wayland/meta-wayland-region.h"
 #include "wayland/meta-wayland-seat.h"
 #include "wayland/meta-wayland-subsurface.h"
+#include "wayland/meta-wayland-transaction.h"
 #include "wayland/meta-wayland-viewporter.h"
 #include "wayland/meta-wayland-xdg-shell.h"
 #include "wayland/meta-window-wayland.h"
@@ -717,7 +718,6 @@ void
 meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
                                   MetaWaylandSurfaceState *state)
 {
-  MetaWaylandSurface *subsurface_surface;
   gboolean had_damage = FALSE;
   int old_width, old_height;
 
@@ -956,14 +956,6 @@ cleanup:
                  surface_state_signals[SURFACE_STATE_SIGNAL_APPLIED],
                  0);
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
-    {
-      MetaWaylandSubsurface *subsurface;
-
-      subsurface = META_WAYLAND_SUBSURFACE (subsurface_surface->role);
-      meta_wayland_subsurface_parent_state_applied (subsurface);
-    }
-
   if (had_damage)
     {
       MetaWindow *toplevel_window;
@@ -984,22 +976,6 @@ cleanup:
     meta_wayland_surface_role_post_apply_state (surface->role, state);
 }
 
-static void
-ensure_cached_state (MetaWaylandSurface *surface)
-{
-  if (!surface->cached_state)
-    surface->cached_state = g_object_new (META_TYPE_WAYLAND_SURFACE_STATE,
-                                          NULL);
-}
-
-void
-meta_wayland_surface_apply_cached_state (MetaWaylandSurface *surface)
-{
-  ensure_cached_state (surface);
-  meta_wayland_surface_apply_state (surface, surface->cached_state);
-  meta_wayland_surface_state_reset (surface->cached_state);
-}
-
 MetaWaylandSurfaceState *
 meta_wayland_surface_get_pending_state (MetaWaylandSurface *surface)
 {
@@ -1028,16 +1004,30 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
    */
   if (meta_wayland_surface_is_synchronized (surface))
     {
-      ensure_cached_state (surface);
-
-      meta_wayland_surface_state_merge_into (pending, surface->cached_state);
+      if (surface->cached_state)
+        {
+          meta_wayland_surface_state_merge_into (pending, surface->cached_state);
+          meta_wayland_surface_state_reset (pending);
+        }
+      else
+        {
+          surface->cached_state = pending;
+          surface->pending_state = meta_wayland_surface_state_new ();
+        }
     }
   else
     {
-      meta_wayland_surface_apply_state (surface, surface->pending_state);
-    }
+      MetaWaylandTransaction *transaction;
 
-  meta_wayland_surface_state_reset (pending);
+      transaction = meta_wayland_transaction_new (surface->compositor);
+      meta_wayland_transaction_add_state (transaction, surface, pending);
+      if (surface->sub.pending_pos)
+          meta_wayland_transaction_add_subsurface_position (transaction, surface);
+      meta_wayland_transaction_add_cached_child_states (transaction, surface);
+      meta_wayland_transaction_commit (transaction);
+
+      surface->pending_state = meta_wayland_surface_state_new ();
+    }
 }
 
 static void
@@ -1745,7 +1735,7 @@ meta_wayland_surface_get_absolute_coordinates (MetaWaylandSurface *surface,
 static void
 meta_wayland_surface_init (MetaWaylandSurface *surface)
 {
-  surface->pending_state = g_object_new (META_TYPE_WAYLAND_SURFACE_STATE, NULL);
+  surface->pending_state = meta_wayland_surface_state_new ();
 
   surface->buffer_ref = meta_wayland_buffer_ref_new ();
 
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 56bcbb1893..ddd86ec1a0 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -276,7 +276,8 @@ void                meta_wayland_surface_apply_state (MetaWaylandSurface      *s
 MetaWaylandSurfaceState *
                     meta_wayland_surface_get_pending_state (MetaWaylandSurface *surface);
 
-void                meta_wayland_surface_apply_cached_state (MetaWaylandSurface *surface);
+MetaWaylandSurfaceState *
+                    meta_wayland_surface_ensure_cached_state (MetaWaylandSurface *surface);
 
 gboolean            meta_wayland_surface_assign_role (MetaWaylandSurface *surface,
                                                       GType               role_type,
@@ -386,6 +387,12 @@ meta_wayland_surface_can_scanout_untransformed (MetaWaylandSurface *surface,
 
 int meta_wayland_surface_get_geometry_scale (MetaWaylandSurface *surface);
 
+static inline MetaWaylandSurfaceState *
+meta_wayland_surface_state_new (void)
+{
+  return g_object_new (META_TYPE_WAYLAND_SURFACE_STATE, NULL);
+}
+
 static inline GNode *
 meta_get_next_subsurface_sibling (GNode *n)
 {
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 96a0b18bc4..bfcf425803 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -41,6 +41,11 @@ struct _MetaWaylandTransaction
 typedef struct _MetaWaylandTransactionEntry
 {
   MetaWaylandSurfaceState *state;
+
+  /* Sub-surface position */
+  gboolean has_sub_pos;
+  int x;
+  int y;
 } MetaWaylandTransactionEntry;
 
 static MetaWaylandTransactionEntry *
@@ -66,6 +71,17 @@ meta_wayland_transaction_sync_child_states (MetaWaylandSurface *surface)
     }
 }
 
+static void
+meta_wayland_transaction_apply_subsurface_position (MetaWaylandSurface          *surface,
+                                                    MetaWaylandTransactionEntry *entry)
+{
+  if (!entry->has_sub_pos)
+    return;
+
+  surface->sub.x = entry->x;
+  surface->sub.y = entry->y;
+}
+
 static gboolean
 is_ancestor (MetaWaylandSurface *candidate,
              MetaWaylandSurface *reference)
@@ -149,11 +165,13 @@ meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
                                 MetaWaylandTransaction **first_candidate)
 {
   g_autofree MetaWaylandSurface **surfaces = NULL;
+  g_autofree MetaWaylandSurfaceState **states = NULL;
   unsigned int num_surfaces;
   int i;
 
   surfaces = (MetaWaylandSurface **)
     g_hash_table_get_keys_as_array (transaction->entries, &num_surfaces);
+  states = g_new (MetaWaylandSurfaceState *, num_surfaces);
 
   /* Sort surfaces from ancestors to descendants */
   qsort (surfaces, num_surfaces, sizeof (MetaWaylandSurface *),
@@ -166,7 +184,10 @@ meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
       MetaWaylandTransactionEntry *entry;
 
       entry = meta_wayland_transaction_get_entry (transaction, surface);
-      meta_wayland_surface_apply_state (surface, entry->state);
+      states[i] = entry->state;
+      meta_wayland_transaction_apply_subsurface_position (surface, entry);
+      if (entry->state)
+        meta_wayland_surface_apply_state (surface, entry->state);
 
       if (surface->transaction.last_committed == transaction)
         {
@@ -188,7 +209,10 @@ meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
 
   /* Synchronize child states from descendants to ancestors */
   for (i = num_surfaces - 1; i >= 0; i--)
-    meta_wayland_transaction_sync_child_states (surfaces[i]);
+    {
+      if (states[i])
+        meta_wayland_transaction_sync_child_states (surfaces[i]);
+    }
 
   meta_wayland_transaction_free (transaction);
 }
@@ -296,6 +320,58 @@ meta_wayland_transaction_add_state (MetaWaylandTransaction  *transaction,
   entry->state = state;
 }
 
+void
+meta_wayland_transaction_add_subsurface_position (MetaWaylandTransaction *transaction,
+                                                  MetaWaylandSurface     *surface)
+{
+  MetaWaylandTransactionEntry *entry;
+
+  entry = meta_wayland_transaction_ensure_entry (transaction, surface);
+  entry->x = surface->sub.pending_x;
+  entry->y = surface->sub.pending_y;
+  entry->has_sub_pos = TRUE;
+  surface->sub.pending_pos = FALSE;
+}
+
+static gboolean
+meta_wayland_transaction_add_cached_state (MetaWaylandTransaction *transaction,
+                                           MetaWaylandSurface     *surface)
+{
+  MetaWaylandSurfaceState *cached = surface->cached_state;
+  gboolean is_synchronized;
+
+  is_synchronized = meta_wayland_surface_is_synchronized (surface);
+
+  if (is_synchronized && cached)
+    {
+      meta_wayland_transaction_add_state (transaction, surface, cached);
+      surface->cached_state = NULL;
+    }
+
+  if (surface->sub.pending_pos)
+    meta_wayland_transaction_add_subsurface_position (transaction, surface);
+
+  return is_synchronized;
+}
+
+void
+meta_wayland_transaction_add_cached_child_states (MetaWaylandTransaction *transaction,
+                                                  MetaWaylandSurface     *surface)
+{
+  MetaWaylandSurface *subsurface_surface;
+
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+    meta_wayland_transaction_add_cached_states (transaction, subsurface_surface);
+}
+
+void
+meta_wayland_transaction_add_cached_states (MetaWaylandTransaction *transaction,
+                                            MetaWaylandSurface     *surface)
+{
+  if (meta_wayland_transaction_add_cached_state (transaction, surface))
+    meta_wayland_transaction_add_cached_child_states (transaction, surface);
+}
+
 static void
 meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
 {
diff --git a/src/wayland/meta-wayland-transaction.h b/src/wayland/meta-wayland-transaction.h
index 230548c193..d79f8d94c1 100644
--- a/src/wayland/meta-wayland-transaction.h
+++ b/src/wayland/meta-wayland-transaction.h
@@ -28,6 +28,15 @@ void meta_wayland_transaction_add_state (MetaWaylandTransaction  *transaction,
                                          MetaWaylandSurface      *surface,
                                          MetaWaylandSurfaceState *state);
 
+void meta_wayland_transaction_add_subsurface_position (MetaWaylandTransaction *transaction,
+                                                       MetaWaylandSurface     *surface);
+
+void meta_wayland_transaction_add_cached_states (MetaWaylandTransaction *transaction,
+                                                 MetaWaylandSurface     *surface);
+
+void meta_wayland_transaction_add_cached_child_states (MetaWaylandTransaction *transaction,
+                                                       MetaWaylandSurface     *surface);
+
 MetaWaylandTransaction *meta_wayland_transaction_new (MetaWaylandCompositor *compositor);
 
 void meta_wayland_transaction_free (MetaWaylandTransaction *transaction);
-- 
2.39.1


From d1bf3a417342462360dc361caee641b49a11c41d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Mon, 7 Jun 2021 15:19:47 +0200
Subject: [PATCH 13/27] wayland/surface: Use transactions for synchronized
 sub-surface state
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Instead of cached_state.

surface_commit for a synchronized sub-surface either commits the
transaction or merges it into the parent surface's transaction (if
the parent is a synchronized sub-surface itself).

This should fix or at least improve the behaviour of nested synchronized
sub-surfaces.

Also change wl_subsurface_set_desync:

* Commit sub-surface transactions separately. This may allow some of
  them to be applied earlier in some cases.
* Commit transaction only for descendant sub-surfaces which become
  newly de-synchronized themselves.

v2:
* Drop unused function prototypes
v3:
* Use g_clear_pointer for surface->sub.transaction.
v4:
* Use g_steal_pointer instead of g_clear_pointer. (Sebastian Wick, Jonas
  Ådahl)
v5: (Carlos Garnacho)
* Add spaces between type casts and values.
* Use (gpointer *) instead of (void**).
v6: (Jonas Ådahl)
* Use g_clear_object in meta_wayland_transaction_entry_merge_into.
* Use meta_wayland_transaction_entry_free in
  meta_wayland_transaction_merge_into.
* Fix alignment of meta_wayland_transaction_merge_pending_state
  parameters.
* Remove unused meta_wayland_transaction_add_state declaration.
v7:
* Use meta_wayland_surface_state_new in
  meta_wayland_transaction_merge_pending_state.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-subsurface.c  |  37 +++++----
 src/wayland/meta-wayland-surface.c     |  62 ++++++++-------
 src/wayland/meta-wayland-surface.h     |  18 +++--
 src/wayland/meta-wayland-transaction.c | 102 +++++++++++++++----------
 src/wayland/meta-wayland-transaction.h |  16 ++--
 5 files changed, 132 insertions(+), 103 deletions(-)

diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index ba86d62060..23168bce14 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -290,10 +290,10 @@ wl_subsurface_set_position (struct wl_client   *client,
                             int32_t             y)
 {
   MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
+  MetaWaylandTransaction *transaction;
 
-  surface->sub.pending_x = x;
-  surface->sub.pending_y = y;
-  surface->sub.pending_pos = TRUE;
+  transaction = meta_wayland_surface_ensure_transaction (surface);
+  meta_wayland_transaction_add_subsurface_position (transaction, surface, x, y);
 }
 
 static gboolean
@@ -417,29 +417,34 @@ wl_subsurface_set_sync (struct wl_client   *client,
   surface->sub.synchronous = TRUE;
 }
 
+static void
+meta_wayland_subsurface_parent_desynced (MetaWaylandSurface *surface)
+{
+  MetaWaylandSurface *subsurface_surface;
+
+  if (surface->sub.synchronous)
+    return;
+
+  if (surface->sub.transaction)
+    meta_wayland_transaction_commit (g_steal_pointer (&surface->sub.transaction));
+
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+    meta_wayland_subsurface_parent_desynced (subsurface_surface);
+}
+
 static void
 wl_subsurface_set_desync (struct wl_client   *client,
                           struct wl_resource *resource)
 {
   MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
-  gboolean is_parent_effectively_synchronized;
 
   if (!surface->sub.synchronous)
     return;
 
-  is_parent_effectively_synchronized =
-    meta_wayland_surface_is_synchronized (surface->sub.parent);
-
-  if (!is_parent_effectively_synchronized)
-    {
-      MetaWaylandTransaction *transaction;
-
-      transaction = meta_wayland_transaction_new (surface->compositor);
-      meta_wayland_transaction_add_cached_states (transaction, surface);
-      meta_wayland_transaction_commit (transaction);
-    }
-
   surface->sub.synchronous = FALSE;
+
+  if (!meta_wayland_surface_is_synchronized (surface))
+    meta_wayland_subsurface_parent_desynced (surface);
 }
 
 static const struct wl_subsurface_interface meta_wayland_wl_subsurface_interface = {
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 852bbed99b..f847bdd8cf 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -535,14 +535,14 @@ meta_wayland_surface_state_clear (MetaWaylandSurfaceState *state)
   meta_wayland_surface_state_discard_presentation_feedback (state);
 }
 
-static void
+void
 meta_wayland_surface_state_reset (MetaWaylandSurfaceState *state)
 {
   meta_wayland_surface_state_clear (state);
   meta_wayland_surface_state_set_default (state);
 }
 
-static void
+void
 meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
                                        MetaWaylandSurfaceState *to)
 {
@@ -982,10 +982,21 @@ meta_wayland_surface_get_pending_state (MetaWaylandSurface *surface)
   return surface->pending_state;
 }
 
+MetaWaylandTransaction *
+meta_wayland_surface_ensure_transaction (MetaWaylandSurface *surface)
+{
+  if (!surface->sub.transaction)
+      surface->sub.transaction = meta_wayland_transaction_new (surface->compositor);
+
+  return surface->sub.transaction;
+}
+
 static void
 meta_wayland_surface_commit (MetaWaylandSurface *surface)
 {
   MetaWaylandSurfaceState *pending = surface->pending_state;
+  MetaWaylandTransaction *transaction;
+  MetaWaylandSurface *subsurface_surface;
 
   COGL_TRACE_BEGIN_SCOPED (MetaWaylandSurfaceCommit,
                            "WaylandSurface (commit)");
@@ -994,6 +1005,23 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
       !meta_wayland_buffer_is_realized (pending->buffer))
     meta_wayland_buffer_realize (pending->buffer);
 
+  if (meta_wayland_surface_is_synchronized (surface))
+    transaction = meta_wayland_surface_ensure_transaction (surface);
+  else
+    transaction = meta_wayland_transaction_new (surface->compositor);
+
+  meta_wayland_transaction_merge_pending_state (transaction, surface);
+
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+    {
+      if (!subsurface_surface->sub.transaction)
+        continue;
+
+      meta_wayland_transaction_merge_into (subsurface_surface->sub.transaction,
+                                           transaction);
+      subsurface_surface->sub.transaction = NULL;
+    }
+
   /*
    * If this is a sub-surface and it is in effective synchronous mode, only
    * cache the pending surface state until either one of the following two
@@ -1002,32 +1030,8 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
    *  2) Its mode changes from synchronized to desynchronized and its parent
    *     surface is in effective desynchronized mode.
    */
-  if (meta_wayland_surface_is_synchronized (surface))
-    {
-      if (surface->cached_state)
-        {
-          meta_wayland_surface_state_merge_into (pending, surface->cached_state);
-          meta_wayland_surface_state_reset (pending);
-        }
-      else
-        {
-          surface->cached_state = pending;
-          surface->pending_state = meta_wayland_surface_state_new ();
-        }
-    }
-  else
-    {
-      MetaWaylandTransaction *transaction;
-
-      transaction = meta_wayland_transaction_new (surface->compositor);
-      meta_wayland_transaction_add_state (transaction, surface, pending);
-      if (surface->sub.pending_pos)
-          meta_wayland_transaction_add_subsurface_position (transaction, surface);
-      meta_wayland_transaction_add_cached_child_states (transaction, surface);
-      meta_wayland_transaction_commit (transaction);
-
-      surface->pending_state = meta_wayland_surface_state_new ();
-    }
+  if (!meta_wayland_surface_is_synchronized (surface))
+    meta_wayland_transaction_commit (transaction);
 }
 
 static void
@@ -1478,8 +1482,8 @@ wl_surface_destructor (struct wl_resource *resource)
   g_clear_pointer (&surface->texture, cogl_object_unref);
   g_clear_pointer (&surface->buffer_ref, meta_wayland_buffer_ref_unref);
 
-  g_clear_object (&surface->cached_state);
   g_clear_object (&surface->pending_state);
+  g_clear_pointer (&surface->sub.transaction, meta_wayland_transaction_free);
 
   if (surface->opaque_region)
     cairo_region_destroy (surface->opaque_region);
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index ddd86ec1a0..1f5eb4f63a 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -191,8 +191,6 @@ struct _MetaWaylandSurface
 
   /* All the pending state that wl_surface.commit will apply. */
   MetaWaylandSurfaceState *pending_state;
-  /* State cached due to inter-surface synchronization such. */
-  MetaWaylandSurfaceState *cached_state;
 
   /* Extension resources. */
   struct wl_resource *wl_subsurface;
@@ -215,9 +213,10 @@ struct _MetaWaylandSurface
      */
     gboolean synchronous;
 
-    int32_t pending_x;
-    int32_t pending_y;
-    gboolean pending_pos;
+    /* Transaction which contains all synchronized state for this sub-surface.
+     * This can include state for nested sub-surfaces.
+     */
+    MetaWaylandTransaction *transaction;
   } sub;
 
   /* wp_viewport */
@@ -270,14 +269,19 @@ MetaWaylandSurface *meta_wayland_surface_create (MetaWaylandCompositor *composit
                                                  struct wl_resource    *compositor_resource,
                                                  guint32                id);
 
+void                meta_wayland_surface_state_reset (MetaWaylandSurfaceState *state);
+
+void                meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
+                                                           MetaWaylandSurfaceState *to);
+
 void                meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
                                                       MetaWaylandSurfaceState *state);
 
 MetaWaylandSurfaceState *
                     meta_wayland_surface_get_pending_state (MetaWaylandSurface *surface);
 
-MetaWaylandSurfaceState *
-                    meta_wayland_surface_ensure_cached_state (MetaWaylandSurface *surface);
+MetaWaylandTransaction *
+                    meta_wayland_surface_ensure_transaction (MetaWaylandSurface *surface);
 
 gboolean            meta_wayland_surface_assign_role (MetaWaylandSurface *surface,
                                                       GType               role_type,
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index bfcf425803..81470a1996 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -308,75 +308,93 @@ meta_wayland_transaction_ensure_entry (MetaWaylandTransaction *transaction,
   return entry;
 }
 
-void
-meta_wayland_transaction_add_state (MetaWaylandTransaction  *transaction,
-                                    MetaWaylandSurface      *surface,
-                                    MetaWaylandSurfaceState *state)
+static void
+meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
 {
-  MetaWaylandTransactionEntry *entry;
-
-  entry = meta_wayland_transaction_ensure_entry (transaction, surface);
-  g_assert (!entry->state);
-  entry->state = state;
+  g_clear_object (&entry->state);
+  g_free (entry);
 }
 
 void
 meta_wayland_transaction_add_subsurface_position (MetaWaylandTransaction *transaction,
-                                                  MetaWaylandSurface     *surface)
+                                                  MetaWaylandSurface     *surface,
+                                                  int                     x,
+                                                  int                     y)
 {
   MetaWaylandTransactionEntry *entry;
 
   entry = meta_wayland_transaction_ensure_entry (transaction, surface);
-  entry->x = surface->sub.pending_x;
-  entry->y = surface->sub.pending_y;
+  entry->x = x;
+  entry->y = y;
   entry->has_sub_pos = TRUE;
-  surface->sub.pending_pos = FALSE;
 }
 
-static gboolean
-meta_wayland_transaction_add_cached_state (MetaWaylandTransaction *transaction,
-                                           MetaWaylandSurface     *surface)
+static void
+meta_wayland_transaction_entry_merge_into (MetaWaylandTransactionEntry *from,
+                                           MetaWaylandTransactionEntry *to)
 {
-  MetaWaylandSurfaceState *cached = surface->cached_state;
-  gboolean is_synchronized;
-
-  is_synchronized = meta_wayland_surface_is_synchronized (surface);
-
-  if (is_synchronized && cached)
+  if (from->has_sub_pos)
     {
-      meta_wayland_transaction_add_state (transaction, surface, cached);
-      surface->cached_state = NULL;
+      to->x = from->x;
+      to->y = from->y;
+      to->has_sub_pos = TRUE;
     }
 
-  if (surface->sub.pending_pos)
-    meta_wayland_transaction_add_subsurface_position (transaction, surface);
+  if (to->state)
+    {
+      meta_wayland_surface_state_merge_into (from->state, to->state);
+      g_clear_object (&from->state);
+      return;
+    }
 
-  return is_synchronized;
+  to->state = from->state;
 }
 
 void
-meta_wayland_transaction_add_cached_child_states (MetaWaylandTransaction *transaction,
-                                                  MetaWaylandSurface     *surface)
+meta_wayland_transaction_merge_into (MetaWaylandTransaction *from,
+                                     MetaWaylandTransaction *to)
 {
-  MetaWaylandSurface *subsurface_surface;
+  GHashTableIter iter;
+  MetaWaylandSurface *surface;
+  MetaWaylandTransactionEntry *from_entry, *to_entry;
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
-    meta_wayland_transaction_add_cached_states (transaction, subsurface_surface);
+  g_hash_table_iter_init (&iter, from->entries);
+  while (g_hash_table_iter_next (&iter, (gpointer *) &surface,
+                                 (gpointer *) &from_entry))
+    {
+      g_hash_table_iter_steal (&iter);
+      to_entry = meta_wayland_transaction_get_entry (to, surface);
+      if (!to_entry)
+        {
+          g_hash_table_insert (to->entries, surface, from_entry);
+          continue;
+        }
+
+      meta_wayland_transaction_entry_merge_into (from_entry, to_entry);
+      meta_wayland_transaction_entry_free (from_entry);
+    }
+
+  meta_wayland_transaction_free (from);
 }
 
 void
-meta_wayland_transaction_add_cached_states (MetaWaylandTransaction *transaction,
-                                            MetaWaylandSurface     *surface)
+meta_wayland_transaction_merge_pending_state (MetaWaylandTransaction *transaction,
+                                              MetaWaylandSurface     *surface)
 {
-  if (meta_wayland_transaction_add_cached_state (transaction, surface))
-    meta_wayland_transaction_add_cached_child_states (transaction, surface);
-}
+  MetaWaylandSurfaceState *pending = surface->pending_state;
+  MetaWaylandTransactionEntry *entry;
 
-static void
-meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
-{
-  g_clear_object (&entry->state);
-  g_free (entry);
+  entry = meta_wayland_transaction_ensure_entry (transaction, surface);
+
+  if (!entry->state)
+    {
+      entry->state = pending;
+      surface->pending_state = meta_wayland_surface_state_new ();
+      return;
+    }
+
+  meta_wayland_surface_state_merge_into (pending, entry->state);
+  meta_wayland_surface_state_reset (pending);
 }
 
 MetaWaylandTransaction *
diff --git a/src/wayland/meta-wayland-transaction.h b/src/wayland/meta-wayland-transaction.h
index d79f8d94c1..720af1f56e 100644
--- a/src/wayland/meta-wayland-transaction.h
+++ b/src/wayland/meta-wayland-transaction.h
@@ -24,18 +24,16 @@
 
 void meta_wayland_transaction_commit (MetaWaylandTransaction *transaction);
 
-void meta_wayland_transaction_add_state (MetaWaylandTransaction  *transaction,
-                                         MetaWaylandSurface      *surface,
-                                         MetaWaylandSurfaceState *state);
-
 void meta_wayland_transaction_add_subsurface_position (MetaWaylandTransaction *transaction,
-                                                       MetaWaylandSurface     *surface);
+                                                       MetaWaylandSurface     *surface,
+                                                       int                     x,
+                                                       int                     y);
 
-void meta_wayland_transaction_add_cached_states (MetaWaylandTransaction *transaction,
-                                                 MetaWaylandSurface     *surface);
+void meta_wayland_transaction_merge_into (MetaWaylandTransaction *from,
+                                          MetaWaylandTransaction *to);
 
-void meta_wayland_transaction_add_cached_child_states (MetaWaylandTransaction *transaction,
-                                                       MetaWaylandSurface     *surface);
+void meta_wayland_transaction_merge_pending_state (MetaWaylandTransaction *transaction,
+                                                   MetaWaylandSurface *surface);
 
 MetaWaylandTransaction *meta_wayland_transaction_new (MetaWaylandCompositor *compositor);
 
-- 
2.39.1


From 4d815f49f35649ef9e6f244dbc9ef6497f1d79f3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Mon, 13 Jun 2022 18:58:56 +0200
Subject: [PATCH 14/27] wayland/surface: Keep transaction entries for all
 referenced surfaces
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This keeps all surfaces referenced by a transaction alive until the
transaction is destroyed, and makes sure transactions are applied in
the same order as they were committed with respect to all surfaces
they reference.

v2:
* Guard against NULL entry in meta_wayland_transaction_apply.
v3:
* Keep single entries hash table.
v4:
* Unref the surface in the meta_wayland_transaction_merge_into while
  loop only if the "to" transaction didn't already have an entry for it,
  to prevent premature finalization of the surface (likely followed by a
  crash).
v5:
* Unref the surface (implicitly via g_hash_table_iter_remove) in the
  meta_wayland_transaction_merge_into while loop even if the "to"
  transaction already had an entry for it, or we leak a reference.
* Use g_clear_object & g_steal_pointer to not leave behind a dangling
  from->state pointer in meta_wayland_transaction_entry_merge_into.
v6:
* Add curly braces around
  meta_wayland_transaction_add_placement_surfaces calls. (Jonas Ådahl)

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-transaction.c | 56 +++++++++++++++++++++++---
 1 file changed, 50 insertions(+), 6 deletions(-)

diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 81470a1996..54f7dec34b 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -35,6 +35,10 @@ struct _MetaWaylandTransaction
   MetaWaylandTransaction *next_candidate;
   uint64_t committed_sequence;
 
+  /*
+   * Keys:   All surfaces referenced in the transaction
+   * Values: Pointer to MetaWaylandTransactionEntry for the surface
+   */
   GHashTable *entries;
 };
 
@@ -303,7 +307,7 @@ meta_wayland_transaction_ensure_entry (MetaWaylandTransaction *transaction,
     return entry;
 
   entry = g_new0 (MetaWaylandTransactionEntry, 1);
-  g_hash_table_insert (transaction->entries, surface, entry);
+  g_hash_table_insert (transaction->entries, g_object_ref (surface), entry);
 
   return entry;
 }
@@ -315,6 +319,39 @@ meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
   g_free (entry);
 }
 
+static void
+meta_wayland_transaction_add_placement_surfaces (MetaWaylandTransaction  *transaction,
+                                                 MetaWaylandSurface      *surface,
+                                                 MetaWaylandSurfaceState *state)
+{
+  GSList *l;
+
+  for (l = state->subsurface_placement_ops; l; l = l->next)
+    {
+      MetaWaylandSubsurfacePlacementOp *op = l->data;
+
+      if (op->surface)
+        meta_wayland_transaction_ensure_entry (transaction, op->surface);
+
+      if (op->sibling)
+        meta_wayland_transaction_ensure_entry (transaction, op->sibling);
+    }
+}
+
+static void
+meta_wayland_transaction_add_entry (MetaWaylandTransaction      *transaction,
+                                    MetaWaylandSurface          *surface,
+                                    MetaWaylandTransactionEntry *entry)
+{
+  g_hash_table_insert (transaction->entries, g_object_ref (surface), entry);
+
+  if (entry->state)
+    {
+      meta_wayland_transaction_add_placement_surfaces (transaction, surface,
+                                                       entry->state);
+    }
+}
+
 void
 meta_wayland_transaction_add_subsurface_position (MetaWaylandTransaction *transaction,
                                                   MetaWaylandSurface     *surface,
@@ -347,7 +384,7 @@ meta_wayland_transaction_entry_merge_into (MetaWaylandTransactionEntry *from,
       return;
     }
 
-  to->state = from->state;
+  to->state = g_steal_pointer (&from->state);
 }
 
 void
@@ -362,16 +399,23 @@ meta_wayland_transaction_merge_into (MetaWaylandTransaction *from,
   while (g_hash_table_iter_next (&iter, (gpointer *) &surface,
                                  (gpointer *) &from_entry))
     {
-      g_hash_table_iter_steal (&iter);
       to_entry = meta_wayland_transaction_get_entry (to, surface);
       if (!to_entry)
         {
-          g_hash_table_insert (to->entries, surface, from_entry);
+          g_hash_table_iter_steal (&iter);
+          meta_wayland_transaction_add_entry (to, surface, from_entry);
+          g_object_unref (surface);
           continue;
         }
 
+      if (from_entry->state)
+        {
+          meta_wayland_transaction_add_placement_surfaces (to, surface,
+                                                           from_entry->state);
+        }
+
       meta_wayland_transaction_entry_merge_into (from_entry, to_entry);
-      meta_wayland_transaction_entry_free (from_entry);
+      g_hash_table_iter_remove (&iter);
     }
 
   meta_wayland_transaction_free (from);
@@ -405,7 +449,7 @@ meta_wayland_transaction_new (MetaWaylandCompositor *compositor)
   transaction = g_new0 (MetaWaylandTransaction, 1);
 
   transaction->compositor = compositor;
-  transaction->entries = g_hash_table_new_full (NULL, NULL, NULL,
+  transaction->entries = g_hash_table_new_full (NULL, NULL, g_object_unref,
                                                 (GDestroyNotify) meta_wayland_transaction_entry_free);
 
   return transaction;
-- 
2.39.1


From 9f2a2c4093e6f5e7757638aa8e0506795475755f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 24 Jun 2022 16:17:23 +0200
Subject: [PATCH 15/27] wayland/surface: Store pointers to next transaction
 with same surface

This saves traversing all committed transactions to find the next one
which references the same surface.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-transaction.c | 41 +++++++++++---------------
 1 file changed, 17 insertions(+), 24 deletions(-)

diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 54f7dec34b..fdc3cad122 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -44,6 +44,9 @@ struct _MetaWaylandTransaction
 
 typedef struct _MetaWaylandTransactionEntry
 {
+  /* Next committed transaction with entry for the same surface */
+  MetaWaylandTransaction *next_transaction;
+
   MetaWaylandSurfaceState *state;
 
   /* Sub-surface position */
@@ -127,24 +130,6 @@ meta_wayland_transaction_compare (const void *key1,
           meta_wayland_surface_get_toplevel (surface2)) ? -1 : 1;
 }
 
-static MetaWaylandTransaction *
-find_next_transaction_for_surface (MetaWaylandTransaction *transaction,
-                                   MetaWaylandSurface     *surface)
-{
-  GList *node;
-
-  for (node = transaction->node.next; node; node = node->next)
-    {
-      MetaWaylandTransaction *next = node->data;
-
-      if (surface->transaction.last_committed == next ||
-          g_hash_table_contains (next->entries, surface))
-        return next;
-    }
-
-  return NULL;
-}
-
 static void
 ensure_next_candidate (MetaWaylandTransaction  *transaction,
                        MetaWaylandTransaction **first_candidate)
@@ -200,9 +185,8 @@ meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
         }
       else
         {
-          MetaWaylandTransaction *next_transaction;
+          MetaWaylandTransaction *next_transaction = entry->next_transaction;
 
-          next_transaction = find_next_transaction_for_surface (transaction, surface);
           if (next_transaction)
             {
               surface->transaction.first_committed = next_transaction;
@@ -284,12 +268,21 @@ meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
   g_hash_table_iter_init (&iter, transaction->entries);
   while (g_hash_table_iter_next (&iter, (gpointer *) &surface, NULL))
     {
-      surface->transaction.last_committed = transaction;
+      if (surface->transaction.first_committed)
+        {
+          MetaWaylandTransactionEntry *entry;
 
-      if (!surface->transaction.first_committed)
-        surface->transaction.first_committed = transaction;
+          entry = g_hash_table_lookup (surface->transaction.last_committed->entries,
+                                       surface);
+          entry->next_transaction = transaction;
+          maybe_apply = FALSE;
+        }
       else
-        maybe_apply = FALSE;
+        {
+          surface->transaction.first_committed = transaction;
+        }
+
+      surface->transaction.last_committed = transaction;
     }
 
   if (maybe_apply)
-- 
2.39.1


From 9c4c29ab866c20241be8408218d705d189f2489d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 23 Jul 2021 18:33:39 +0200
Subject: [PATCH 16/27] wayland/surface: Two phase surface destruction

Destroy Wayland protocol related state immediately when the Wayland
resource is destroyed, but keep the rest alive by any transaction which
references the surface.

This makes it easier and cleaner to deal with a surface getting
destroyed while it's still referenced by transactions.

v2:
* No more need to keep references for surfaces in the entries hash
  table.
v3:
* Do not use surface->sub.transaction in wl_surface_destructor, just
  destroy it.
v4:
* No need for wl_surface_destructor to use its own transaction.
v5:
* Use g_steal_pointer & (more) g_clear_pointer in wl_surface_destructor.
v6:
* Leave SURFACE_DESTROY signal emission in wl_surface_destructor.
v7:
* Use finalize instead of dispose callback.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-surface.c | 36 +++++++++++++++++++++---------
 1 file changed, 26 insertions(+), 10 deletions(-)

diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index f847bdd8cf..1752cde8f1 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -1460,14 +1460,12 @@ meta_wayland_surface_notify_unmapped (MetaWaylandSurface *surface)
 }
 
 static void
-wl_surface_destructor (struct wl_resource *resource)
+meta_wayland_surface_finalize (GObject *object)
 {
-  MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
+  MetaWaylandSurface *surface = META_WAYLAND_SURFACE (object);
   MetaWaylandCompositor *compositor = surface->compositor;
   MetaWaylandFrameCallback *cb, *next;
 
-  g_signal_emit (surface, surface_signals[SURFACE_DESTROY], 0);
-
   g_clear_object (&surface->scanout_candidate);
   g_clear_object (&surface->role);
 
@@ -1482,9 +1480,6 @@ wl_surface_destructor (struct wl_resource *resource)
   g_clear_pointer (&surface->texture, cogl_object_unref);
   g_clear_pointer (&surface->buffer_ref, meta_wayland_buffer_ref_unref);
 
-  g_clear_object (&surface->pending_state);
-  g_clear_pointer (&surface->sub.transaction, meta_wayland_transaction_free);
-
   if (surface->opaque_region)
     cairo_region_destroy (surface->opaque_region);
   if (surface->input_region)
@@ -1506,13 +1501,33 @@ wl_surface_destructor (struct wl_resource *resource)
 
   meta_wayland_surface_discard_presentation_feedback (surface);
 
-  if (surface->wl_subsurface)
-    wl_resource_destroy (surface->wl_subsurface);
-
   g_clear_pointer (&surface->subsurface_branch_node, g_node_destroy);
 
   g_hash_table_destroy (surface->shortcut_inhibited_seats);
 
+  G_OBJECT_CLASS (meta_wayland_surface_parent_class)->finalize (object);
+}
+
+static void
+wl_surface_destructor (struct wl_resource *resource)
+{
+  MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
+
+  g_signal_emit (surface, surface_signals[SURFACE_DESTROY], 0);
+
+  g_clear_object (&surface->pending_state);
+  g_clear_pointer (&surface->sub.transaction, meta_wayland_transaction_free);
+
+  if (surface->resource)
+    wl_resource_set_user_data (g_steal_pointer (&surface->resource), NULL);
+
+  g_clear_pointer (&surface->wl_subsurface, wl_resource_destroy);
+
+  /*
+   * Any transactions referencing this surface will keep it alive until they get
+   * applied/destroyed. The last reference will be dropped in
+   * meta_wayland_transaction_free.
+   */
   g_object_unref (surface);
 }
 
@@ -1772,6 +1787,7 @@ meta_wayland_surface_class_init (MetaWaylandSurfaceClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
+  object_class->finalize = meta_wayland_surface_finalize;
   object_class->get_property = meta_wayland_surface_get_property;
 
   obj_props[PROP_SCANOUT_CANDIDATE] =
-- 
2.39.1


From 20afa3ad4937fefc427a940fdfb30e9d7a0820b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 23 Jul 2021 16:01:37 +0200
Subject: [PATCH 17/27] wayland/surface: Use transactions for all sub-surface
 hierarchy changes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

And keep track of the hierarchy separately for the Wayland protocol and
for output. Protocol state is updated immediately as protocol requests
are processed, output state only when the corresponding transaction is
applied (which may be deferred until the next commit of the parent
surface).

v2:
* Directly add placement ops to a transaction, instead of going via
  pending_state.
* Use transaction entry for the sub-surface instead of that for its
  parent surface.
v3:
* Use transaction entry for the parent surface again, to ensure proper
  ordering of placement ops, and call
  meta_wayland_surface_notify_subsurface_state_changed only once per
  parent surface.
* Drop all use of wl_resource_add_destroy_listener, transactions are
  keeping surfaces alive as long as needed.
v4:
* Rebase on https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2501
* Drop ClutterActor code from meta_wayland_surface_apply_placement_ops.
  (Robert Mader)
v5:
* Rename MetaWaylandSubSurfaceState to MetaWaylandSurfaceSubState, since
  the next commit adds not sub-surface specific state to it.
v6:
* Move include of meta-wayland-subsurface.h from
  meta-wayland-transaction.c to .h, since the latter references
  MetaWaylandSubsurfacePlacementOp.
v7:
* Drop superfluous !entry check from meta_wayland_transaction_apply.
v8:
* Rename output/protocol fields to output/protocol_state. (Jonas Ådahl)
v9:
* Use meta_wayland_surface_state_new in
  meta_wayland_transaction_add_placement_op.
v10:
* Fix a few style issues per check-style.py.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/compositor/meta-window-actor-wayland.c |   2 +-
 src/wayland/meta-wayland-actor-surface.c   |   6 +-
 src/wayland/meta-wayland-pointer.c         |   3 +-
 src/wayland/meta-wayland-shell-surface.c   |   3 +-
 src/wayland/meta-wayland-subsurface.c      | 184 ++++++++++-----------
 src/wayland/meta-wayland-subsurface.h      |   4 +-
 src/wayland/meta-wayland-surface.c         | 106 +++++++-----
 src/wayland/meta-wayland-surface.h         |  26 +--
 src/wayland/meta-wayland-tablet-tool.c     |   3 +-
 src/wayland/meta-wayland-transaction.c     |  62 ++++---
 src/wayland/meta-wayland-transaction.h     |   5 +
 11 files changed, 226 insertions(+), 178 deletions(-)

diff --git a/src/compositor/meta-window-actor-wayland.c b/src/compositor/meta-window-actor-wayland.c
index 29278a5182..21c04b2709 100644
--- a/src/compositor/meta-window-actor-wayland.c
+++ b/src/compositor/meta-window-actor-wayland.c
@@ -197,7 +197,7 @@ meta_window_actor_wayland_rebuild_surface_tree (MetaWindowActor *actor)
     meta_window_actor_get_surface (actor);
   MetaWaylandSurface *surface = meta_surface_actor_wayland_get_surface (
     META_SURFACE_ACTOR_WAYLAND (surface_actor));
-  GNode *root_node = surface->subsurface_branch_node;
+  GNode *root_node = surface->output_state.subsurface_branch_node;
   g_autoptr (GList) surface_actors = NULL;
   g_autoptr (GList) children = NULL;
   GList *l;
diff --git a/src/wayland/meta-wayland-actor-surface.c b/src/wayland/meta-wayland-actor-surface.c
index 2b76d943a5..87192825b0 100644
--- a/src/wayland/meta-wayland-actor-surface.c
+++ b/src/wayland/meta-wayland-actor-surface.c
@@ -273,7 +273,8 @@ meta_wayland_actor_surface_real_sync_actor_state (MetaWaylandActorSurface *actor
 
   meta_shaped_texture_ensure_size_valid (stex);
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state,
+                                           subsurface_surface)
     {
       MetaWaylandActorSurface *actor_surface;
 
@@ -422,7 +423,8 @@ meta_wayland_actor_surface_reset_actor (MetaWaylandActorSurface *actor_surface)
     meta_wayland_surface_role_get_surface (META_WAYLAND_SURFACE_ROLE (actor_surface));
   MetaWaylandSurface *subsurface_surface;
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state,
+                                           subsurface_surface)
     {
       MetaWaylandActorSurface *actor_surface;
 
diff --git a/src/wayland/meta-wayland-pointer.c b/src/wayland/meta-wayland-pointer.c
index d000ccfd86..314adec27c 100644
--- a/src/wayland/meta-wayland-pointer.c
+++ b/src/wayland/meta-wayland-pointer.c
@@ -1369,7 +1369,8 @@ pointer_can_grab_surface (MetaWaylandPointer *pointer,
   if (pointer->focus_surface == surface)
     return TRUE;
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state,
+                                           subsurface)
     {
       if (pointer_can_grab_surface (pointer, subsurface))
         return TRUE;
diff --git a/src/wayland/meta-wayland-shell-surface.c b/src/wayland/meta-wayland-shell-surface.c
index c2e8c5fc70..a98101a593 100644
--- a/src/wayland/meta-wayland-shell-surface.c
+++ b/src/wayland/meta-wayland-shell-surface.c
@@ -59,7 +59,8 @@ meta_wayland_shell_surface_calculate_geometry (MetaWaylandShellSurface *shell_su
     .height = meta_wayland_surface_get_height (surface),
   };
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state,
+                                           subsurface_surface)
     {
       MetaWaylandSubsurface *subsurface;
 
diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index 23168bce14..d86e66ab0b 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -50,7 +50,7 @@ transform_subsurface_position (MetaWaylandSurface *surface,
       *x += surface->sub.x;
       *y += surface->sub.y;
 
-      surface = surface->sub.parent;
+      surface = surface->output_state.parent;
     }
   while (surface);
 }
@@ -60,8 +60,8 @@ should_show (MetaWaylandSurface *surface)
 {
   if (!surface->buffer_ref->buffer)
     return FALSE;
-  else if (surface->sub.parent)
-    return should_show (surface->sub.parent);
+  else if (surface->output_state.parent)
+    return should_show (surface->output_state.parent);
   else
     return TRUE;
 }
@@ -96,14 +96,15 @@ static gboolean
 is_child (MetaWaylandSurface *surface,
           MetaWaylandSurface *sibling)
 {
-   return surface->sub.parent == sibling;
+  return surface->protocol_state.parent == sibling;
 }
 
 static gboolean
 is_sibling (MetaWaylandSurface *surface,
             MetaWaylandSurface *sibling)
 {
-  return surface != sibling && surface->sub.parent == sibling->sub.parent;
+  return surface != sibling &&
+         surface->protocol_state.parent == sibling->protocol_state.parent;
 }
 
 void
@@ -128,7 +129,8 @@ meta_wayland_subsurface_union_geometry (MetaWaylandSubsurface *subsurface,
   if (surface->buffer_ref->buffer)
     meta_rectangle_union (out_geometry, &geometry, out_geometry);
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state,
+                                           subsurface_surface)
     {
       MetaWaylandSubsurface *subsurface;
 
@@ -158,7 +160,7 @@ meta_wayland_subsurface_get_toplevel (MetaWaylandSurfaceRole *surface_role)
 {
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
-  MetaWaylandSurface *parent = surface->sub.parent;
+  MetaWaylandSurface *parent = surface->output_state.parent;
 
   if (parent)
     return meta_wayland_surface_get_toplevel (parent);
@@ -176,7 +178,7 @@ meta_wayland_subsurface_is_synchronized (MetaWaylandSurfaceRole *surface_role)
   if (surface->sub.synchronous)
     return TRUE;
 
-  parent = surface->sub.parent;
+  parent = surface->protocol_state.parent;
   if (parent)
     return meta_wayland_surface_is_synchronized (parent);
 
@@ -188,7 +190,7 @@ meta_wayland_subsurface_notify_subsurface_state_changed (MetaWaylandSurfaceRole
 {
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
-  MetaWaylandSurface *parent = surface->sub.parent;
+  MetaWaylandSurface *parent = surface->output_state.parent;
 
   if (parent)
     return meta_wayland_surface_notify_subsurface_state_changed (parent);
@@ -201,13 +203,14 @@ meta_wayland_subsurface_get_geometry_scale (MetaWaylandActorSurface *actor_surfa
     META_WAYLAND_SURFACE_ROLE (actor_surface);
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
-  MetaWaylandSurface *parent = surface->sub.parent;
+  MetaWaylandSurface *parent = surface->output_state.parent;
 
   if (parent)
     {
       MetaWaylandActorSurface *parent_actor;
 
-      parent_actor = META_WAYLAND_ACTOR_SURFACE (surface->sub.parent->role);
+      parent_actor =
+        META_WAYLAND_ACTOR_SURFACE (surface->output_state.parent->role);
       return meta_wayland_actor_surface_get_geometry_scale (parent_actor);
     }
   else
@@ -259,23 +262,6 @@ meta_wayland_subsurface_class_init (MetaWaylandSubsurfaceClass *klass)
     meta_wayland_subsurface_sync_actor_state;
 }
 
-static void
-wl_subsurface_destructor (struct wl_resource *resource)
-{
-  MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
-
-  g_node_unlink (surface->subsurface_branch_node);
-
-  if (surface->sub.parent)
-    {
-      meta_wayland_surface_notify_subsurface_state_changed (surface->sub.parent);
-      wl_list_remove (&surface->sub.parent_destroy_listener.link);
-      surface->sub.parent = NULL;
-    }
-
-  surface->wl_subsurface = NULL;
-}
-
 static void
 wl_subsurface_destroy (struct wl_client   *client,
                        struct wl_resource *resource)
@@ -307,61 +293,57 @@ is_valid_sibling (MetaWaylandSurface *surface,
   return FALSE;
 }
 
-static void
-subsurface_handle_pending_subsurface_destroyed (struct wl_listener *listener,
-                                                void               *data)
-{
-  MetaWaylandSubsurfacePlacementOp *op =
-    wl_container_of (listener, op, subsurface_destroy_listener);
-
-  op->surface = NULL;
-  wl_list_remove (&op->subsurface_destroy_listener.link);
-}
-
-static void
-subsurface_handle_pending_sibling_destroyed (struct wl_listener *listener,
-                                             void               *data)
-{
-  MetaWaylandSubsurfacePlacementOp *op =
-    wl_container_of (listener, op, sibling_destroy_listener);
-
-  op->sibling = NULL;
-  wl_list_remove (&op->sibling_destroy_listener.link);
-}
-
-void
-meta_wayland_subsurface_placement_op_free (MetaWaylandSubsurfacePlacementOp *op)
-{
-  if (op->surface)
-    wl_list_remove (&op->subsurface_destroy_listener.link);
-  if (op->sibling)
-    wl_list_remove (&op->sibling_destroy_listener.link);
-  g_free (op);
-}
-
 static void
 queue_subsurface_placement (MetaWaylandSurface             *surface,
                             MetaWaylandSurface             *sibling,
                             MetaWaylandSubsurfacePlacement  placement)
 {
-  MetaWaylandSurface *parent = surface->sub.parent;
+  MetaWaylandSurface *parent = surface->protocol_state.parent;
+  gboolean have_synced_parent;
+  MetaWaylandTransaction *transaction;
   MetaWaylandSubsurfacePlacementOp *op =
     g_new0 (MetaWaylandSubsurfacePlacementOp, 1);
+  GNode *sibling_node;
+
+  have_synced_parent = sibling && meta_wayland_surface_is_synchronized (parent);
+  if (have_synced_parent)
+    transaction = meta_wayland_surface_ensure_transaction (parent);
+  else
+    transaction = meta_wayland_transaction_new (surface->compositor);
 
   op->placement = placement;
-  op->surface = surface;
   op->sibling = sibling;
-  op->subsurface_destroy_listener.notify =
-    subsurface_handle_pending_subsurface_destroyed;
-  op->sibling_destroy_listener.notify =
-    subsurface_handle_pending_sibling_destroyed;
-  wl_resource_add_destroy_listener (surface->wl_subsurface,
-                                    &op->subsurface_destroy_listener);
-  wl_resource_add_destroy_listener (sibling->resource,
-                                    &op->sibling_destroy_listener);
-
-  parent->pending_state->subsurface_placement_ops =
-    g_slist_append (parent->pending_state->subsurface_placement_ops, op);
+  op->surface = surface;
+
+  g_node_unlink (surface->protocol_state.subsurface_branch_node);
+
+  if (!sibling)
+    goto out;
+
+  if (sibling == parent)
+    sibling_node = parent->protocol_state.subsurface_leaf_node;
+  else
+    sibling_node = sibling->protocol_state.subsurface_branch_node;
+
+  switch (placement)
+    {
+    case META_WAYLAND_SUBSURFACE_PLACEMENT_ABOVE:
+      g_node_insert_after (parent->protocol_state.subsurface_branch_node,
+                           sibling_node,
+                           surface->protocol_state.subsurface_branch_node);
+      break;
+    case META_WAYLAND_SUBSURFACE_PLACEMENT_BELOW:
+      g_node_insert_before (parent->protocol_state.subsurface_branch_node,
+                            sibling_node,
+                            surface->protocol_state.subsurface_branch_node);
+      break;
+    }
+
+out:
+  meta_wayland_transaction_add_placement_op (transaction, parent, op);
+
+  if (!have_synced_parent)
+    meta_wayland_transaction_commit (transaction);
 }
 
 static void
@@ -408,6 +390,25 @@ wl_subsurface_place_below (struct wl_client   *client,
                               META_WAYLAND_SUBSURFACE_PLACEMENT_BELOW);
 }
 
+static void
+wl_subsurface_destructor (struct wl_resource *resource)
+{
+  MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
+
+  if (surface->protocol_state.parent)
+    {
+      queue_subsurface_placement (surface, NULL,
+                                  META_WAYLAND_SUBSURFACE_PLACEMENT_BELOW);
+      surface->protocol_state.parent = NULL;
+    }
+  else
+    {
+      g_node_unlink (surface->protocol_state.subsurface_branch_node);
+    }
+
+  surface->wl_subsurface = NULL;
+}
+
 static void
 wl_subsurface_set_sync (struct wl_client   *client,
                         struct wl_resource *resource)
@@ -428,7 +429,8 @@ meta_wayland_subsurface_parent_desynced (MetaWaylandSurface *surface)
   if (surface->sub.transaction)
     meta_wayland_transaction_commit (g_steal_pointer (&surface->sub.transaction));
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->protocol_state,
+                                           subsurface_surface)
     meta_wayland_subsurface_parent_desynced (subsurface_surface);
 }
 
@@ -463,17 +465,12 @@ wl_subcompositor_destroy (struct wl_client   *client,
   wl_resource_destroy (resource);
 }
 
-static void
-surface_handle_parent_surface_destroyed (struct wl_listener *listener,
-                                         void               *data)
+void
+meta_wayland_subsurface_parent_destroyed (MetaWaylandSurface *surface)
 {
-  MetaWaylandSurface *surface = wl_container_of (listener,
-                                                 surface,
-                                                 sub.parent_destroy_listener);
-
-  g_node_unlink (surface->subsurface_branch_node);
-  surface->sub.parent = NULL;
-  wl_list_remove (&surface->sub.parent_destroy_listener.link);
+  queue_subsurface_placement (surface, NULL,
+                              META_WAYLAND_SUBSURFACE_PLACEMENT_BELOW);
+  surface->protocol_state.parent = NULL;
 }
 
 static gboolean
@@ -482,8 +479,8 @@ is_same_or_ancestor (MetaWaylandSurface *surface,
 {
   if (surface == other_surface)
     return TRUE;
-  if (other_surface->sub.parent)
-    return is_same_or_ancestor (surface, other_surface->sub.parent);
+  if (other_surface->protocol_state.parent)
+    return is_same_or_ancestor (surface, other_surface->protocol_state.parent);
   return FALSE;
 }
 
@@ -496,6 +493,7 @@ wl_subcompositor_get_subsurface (struct wl_client   *client,
 {
   MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
   MetaWaylandSurface *parent = wl_resource_get_user_data (parent_resource);
+  MetaWaylandSurface *reference;
   MetaWindow *toplevel_window;
 
   if (surface->wl_subsurface)
@@ -542,16 +540,12 @@ wl_subcompositor_get_subsurface (struct wl_client   *client,
                                   wl_subsurface_destructor);
 
   surface->sub.synchronous = TRUE;
-  surface->sub.parent = parent;
-  surface->sub.parent_destroy_listener.notify =
-    surface_handle_parent_surface_destroyed;
-  wl_resource_add_destroy_listener (parent->resource,
-                                    &surface->sub.parent_destroy_listener);
-
-  g_node_append (parent->subsurface_branch_node,
-                 surface->subsurface_branch_node);
+  surface->protocol_state.parent = parent;
 
-  meta_wayland_surface_notify_subsurface_state_changed (parent);
+  reference =
+    g_node_last_child (parent->protocol_state.subsurface_branch_node)->data;
+  queue_subsurface_placement (surface, reference,
+                              META_WAYLAND_SUBSURFACE_PLACEMENT_ABOVE);
 }
 
 static const struct wl_subcompositor_interface meta_wayland_subcompositor_interface = {
diff --git a/src/wayland/meta-wayland-subsurface.h b/src/wayland/meta-wayland-subsurface.h
index 5fa2999db4..61338e9216 100644
--- a/src/wayland/meta-wayland-subsurface.h
+++ b/src/wayland/meta-wayland-subsurface.h
@@ -40,8 +40,6 @@ typedef struct
   MetaWaylandSubsurfacePlacement placement;
   MetaWaylandSurface *surface;
   MetaWaylandSurface *sibling;
-  struct wl_listener subsurface_destroy_listener;
-  struct wl_listener sibling_destroy_listener;
 } MetaWaylandSubsurfacePlacementOp;
 
 void meta_wayland_subsurface_union_geometry (MetaWaylandSubsurface *subsurface,
@@ -49,7 +47,7 @@ void meta_wayland_subsurface_union_geometry (MetaWaylandSubsurface *subsurface,
                                              int                    parent_y,
                                              MetaRectangle         *out_geometry);
 
-void meta_wayland_subsurface_placement_op_free (MetaWaylandSubsurfacePlacementOp *op);
+void meta_wayland_subsurface_parent_destroyed (MetaWaylandSurface *surface);
 
 void meta_wayland_subsurfaces_init (MetaWaylandCompositor *compositor);
 
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 1752cde8f1..f5487936d3 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -526,11 +526,7 @@ meta_wayland_surface_state_clear (MetaWaylandSurfaceState *state)
     wl_resource_destroy (cb->resource);
 
   if (state->subsurface_placement_ops)
-    {
-      g_slist_free_full (
-        state->subsurface_placement_ops,
-        (GDestroyNotify) meta_wayland_subsurface_placement_op_free);
-    }
+    g_slist_free_full (state->subsurface_placement_ops, g_free);
 
   meta_wayland_surface_state_discard_presentation_feedback (state);
 }
@@ -714,6 +710,49 @@ meta_wayland_surface_discard_presentation_feedback (MetaWaylandSurface *surface)
     }
 }
 
+void
+meta_wayland_surface_apply_placement_ops (MetaWaylandSurface      *parent,
+                                          MetaWaylandSurfaceState *state)
+{
+  GSList *l;
+
+  for (l = state->subsurface_placement_ops; l; l = l->next)
+    {
+      MetaWaylandSubsurfacePlacementOp *op = l->data;
+      MetaWaylandSurface *surface = op->surface;
+      GNode *sibling_node;
+
+      g_node_unlink (surface->output_state.subsurface_branch_node);
+
+      if (!op->sibling)
+        {
+          surface->output_state.parent = NULL;
+          continue;
+        }
+
+      surface->output_state.parent = parent;
+
+      if (op->sibling == parent)
+        sibling_node = parent->output_state.subsurface_leaf_node;
+      else
+        sibling_node = op->sibling->output_state.subsurface_branch_node;
+
+      switch (op->placement)
+        {
+        case META_WAYLAND_SUBSURFACE_PLACEMENT_ABOVE:
+          g_node_insert_after (parent->output_state.subsurface_branch_node,
+                               sibling_node,
+                               surface->output_state.subsurface_branch_node);
+          break;
+        case META_WAYLAND_SUBSURFACE_PLACEMENT_BELOW:
+          g_node_insert_before (parent->output_state.subsurface_branch_node,
+                                sibling_node,
+                                surface->output_state.subsurface_branch_node);
+          break;
+        }
+    }
+}
+
 void
 meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
                                   MetaWaylandSurfaceState *state)
@@ -908,41 +947,7 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
     }
 
   if (state->subsurface_placement_ops)
-    {
-      GSList *l;
-
-      for (l = state->subsurface_placement_ops; l; l = l->next)
-        {
-          MetaWaylandSubsurfacePlacementOp *op = l->data;
-          GNode *sibling_node;
-
-          if (!op->surface || !op->sibling)
-            continue;
-
-          if (op->sibling == surface)
-            sibling_node = surface->subsurface_leaf_node;
-          else
-            sibling_node = op->sibling->subsurface_branch_node;
-
-          g_node_unlink (op->surface->subsurface_branch_node);
-
-          switch (op->placement)
-            {
-            case META_WAYLAND_SUBSURFACE_PLACEMENT_ABOVE:
-              g_node_insert_after (surface->subsurface_branch_node,
-                                   sibling_node,
-                                   op->surface->subsurface_branch_node);
-              break;
-            case META_WAYLAND_SUBSURFACE_PLACEMENT_BELOW:
-              g_node_insert_before (surface->subsurface_branch_node,
-                                    sibling_node,
-                                    op->surface->subsurface_branch_node);
-              break;
-            }
-        }
-
-      meta_wayland_surface_notify_subsurface_state_changed (surface);
-    }
+    meta_wayland_surface_notify_subsurface_state_changed (surface);
 
 cleanup:
   /* If we have a buffer that we are not using, decrease the use count so it may
@@ -1012,7 +1017,8 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
 
   meta_wayland_transaction_merge_pending_state (transaction, surface);
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->protocol_state,
+                                           subsurface_surface)
     {
       if (!subsurface_surface->sub.transaction)
         continue;
@@ -1501,7 +1507,7 @@ meta_wayland_surface_finalize (GObject *object)
 
   meta_wayland_surface_discard_presentation_feedback (surface);
 
-  g_clear_pointer (&surface->subsurface_branch_node, g_node_destroy);
+  g_clear_pointer (&surface->output_state.subsurface_branch_node, g_node_destroy);
 
   g_hash_table_destroy (surface->shortcut_inhibited_seats);
 
@@ -1512,6 +1518,7 @@ static void
 wl_surface_destructor (struct wl_resource *resource)
 {
   MetaWaylandSurface *surface = wl_resource_get_user_data (resource);
+  MetaWaylandSurface *subsurface_surface;
 
   g_signal_emit (surface, surface_signals[SURFACE_DESTROY], 0);
 
@@ -1521,7 +1528,12 @@ wl_surface_destructor (struct wl_resource *resource)
   if (surface->resource)
     wl_resource_set_user_data (g_steal_pointer (&surface->resource), NULL);
 
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->protocol_state,
+                                           subsurface_surface)
+    meta_wayland_subsurface_parent_destroyed (subsurface_surface);
+
   g_clear_pointer (&surface->wl_subsurface, wl_resource_destroy);
+  g_clear_pointer (&surface->protocol_state.subsurface_branch_node, g_node_destroy);
 
   /*
    * Any transactions referencing this surface will keep it alive until they get
@@ -1758,9 +1770,13 @@ meta_wayland_surface_init (MetaWaylandSurface *surface)
 
   surface->buffer_ref = meta_wayland_buffer_ref_new ();
 
-  surface->subsurface_branch_node = g_node_new (surface);
-  surface->subsurface_leaf_node =
-    g_node_prepend_data (surface->subsurface_branch_node, surface);
+  surface->output_state.subsurface_branch_node = g_node_new (surface);
+  surface->output_state.subsurface_leaf_node =
+    g_node_prepend_data (surface->output_state.subsurface_branch_node, surface);
+
+  surface->protocol_state.subsurface_branch_node = g_node_new (surface);
+  surface->protocol_state.subsurface_leaf_node =
+    g_node_prepend_data (surface->protocol_state.subsurface_branch_node, surface);
 }
 
 static void
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 1f5eb4f63a..7aab3f2c7b 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -166,8 +166,6 @@ struct _MetaWaylandSurface
   cairo_region_t *opaque_region;
   int scale;
   int32_t offset_x, offset_y;
-  GNode *subsurface_branch_node;
-  GNode *subsurface_leaf_node;
   GHashTable *outputs;
   MetaMonitorTransform buffer_transform;
 
@@ -192,14 +190,17 @@ struct _MetaWaylandSurface
   /* All the pending state that wl_surface.commit will apply. */
   MetaWaylandSurfaceState *pending_state;
 
+  struct MetaWaylandSurfaceSubState {
+    MetaWaylandSurface *parent;
+    GNode *subsurface_branch_node;
+    GNode *subsurface_leaf_node;
+  } output_state, protocol_state;
+
   /* Extension resources. */
   struct wl_resource *wl_subsurface;
 
   /* wl_subsurface stuff. */
   struct {
-    MetaWaylandSurface *parent;
-    struct wl_listener parent_destroy_listener;
-
     int x;
     int y;
 
@@ -274,6 +275,9 @@ void                meta_wayland_surface_state_reset (MetaWaylandSurfaceState *s
 void                meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
                                                            MetaWaylandSurfaceState *to);
 
+void                meta_wayland_surface_apply_placement_ops (MetaWaylandSurface      *surface,
+                                                              MetaWaylandSurfaceState *state);
+
 void                meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
                                                       MetaWaylandSurfaceState *state);
 
@@ -415,11 +419,11 @@ meta_get_next_subsurface_sibling (GNode *n)
 }
 
 static inline GNode *
-meta_get_first_subsurface_node (MetaWaylandSurface *surface)
+meta_get_first_subsurface_node (struct MetaWaylandSurfaceSubState *sub)
 {
   GNode *n;
 
-  n = g_node_first_child (surface->subsurface_branch_node);
+  n = g_node_first_child (sub->subsurface_branch_node);
   if (!n)
     return NULL;
   else if (!G_NODE_IS_LEAF (n))
@@ -428,9 +432,11 @@ meta_get_first_subsurface_node (MetaWaylandSurface *surface)
     return meta_get_next_subsurface_sibling (n);
 }
 
-#define META_WAYLAND_SURFACE_FOREACH_SUBSURFACE(surface, subsurface) \
-  for (GNode *G_PASTE(__n, __LINE__) = meta_get_first_subsurface_node ((surface)); \
+#define META_WAYLAND_SURFACE_FOREACH_SUBSURFACE(state, subsurface) \
+  for (GNode *G_PASTE(__n, __LINE__) = meta_get_first_subsurface_node (state), \
+       *G_PASTE(__next, __LINE__) = meta_get_next_subsurface_sibling (G_PASTE (__n, __LINE__)); \
        (subsurface = (G_PASTE (__n, __LINE__) ? G_PASTE (__n, __LINE__)->data : NULL)); \
-       G_PASTE (__n, __LINE__) = meta_get_next_subsurface_sibling (G_PASTE (__n, __LINE__)))
+       G_PASTE (__n, __LINE__) = G_PASTE (__next, __LINE__), \
+       G_PASTE (__next, __LINE__) = meta_get_next_subsurface_sibling (G_PASTE (__n, __LINE__)))
 
 #endif
diff --git a/src/wayland/meta-wayland-tablet-tool.c b/src/wayland/meta-wayland-tablet-tool.c
index 27d31a5b2b..ef53589475 100644
--- a/src/wayland/meta-wayland-tablet-tool.c
+++ b/src/wayland/meta-wayland-tablet-tool.c
@@ -899,7 +899,8 @@ tablet_tool_can_grab_surface (MetaWaylandTabletTool *tool,
   if (tool->focus_surface == surface)
     return TRUE;
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state,
+                                           subsurface)
     {
       if (tablet_tool_can_grab_surface (tool, subsurface))
         return TRUE;
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index fdc3cad122..56aaf3923f 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -24,7 +24,6 @@
 #include "wayland/meta-wayland-transaction.h"
 
 #include "wayland/meta-wayland.h"
-#include "wayland/meta-wayland-subsurface.h"
 
 #define META_WAYLAND_TRANSACTION_NONE ((void *)(uintptr_t) G_MAXSIZE)
 
@@ -67,7 +66,7 @@ meta_wayland_transaction_sync_child_states (MetaWaylandSurface *surface)
 {
   MetaWaylandSurface *subsurface_surface;
 
-  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (surface, subsurface_surface)
+  META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state, subsurface_surface)
     {
       MetaWaylandSubsurface *subsurface;
       MetaWaylandActorSurface *actor_surface;
@@ -95,7 +94,9 @@ is_ancestor (MetaWaylandSurface *candidate,
 {
   MetaWaylandSurface *ancestor;
 
-  for (ancestor = reference->sub.parent; ancestor; ancestor = ancestor->sub.parent)
+  for (ancestor = reference->output_state.parent;
+       ancestor;
+       ancestor = ancestor->output_state.parent)
     {
       if (ancestor == candidate)
         return TRUE;
@@ -112,7 +113,7 @@ meta_wayland_transaction_compare (const void *key1,
   MetaWaylandSurface *surface2 = *(MetaWaylandSurface **) key2;
 
   /* Order of siblings doesn't matter */
-  if (surface1->sub.parent == surface2->sub.parent)
+  if (surface1->output_state.parent == surface2->output_state.parent)
     return 0;
 
   /* Ancestor surfaces come before descendant surfaces */
@@ -156,12 +157,25 @@ meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
   g_autofree MetaWaylandSurface **surfaces = NULL;
   g_autofree MetaWaylandSurfaceState **states = NULL;
   unsigned int num_surfaces;
+  MetaWaylandSurface *surface;
+  MetaWaylandTransactionEntry *entry;
   int i;
 
   surfaces = (MetaWaylandSurface **)
     g_hash_table_get_keys_as_array (transaction->entries, &num_surfaces);
   states = g_new (MetaWaylandSurfaceState *, num_surfaces);
 
+  /* Apply sub-surface states to ensure output surface hierarchy is up to date */
+  for (i = 0; i < num_surfaces; i++)
+    {
+      surface = surfaces[i];
+      entry = meta_wayland_transaction_get_entry (transaction, surface);
+      meta_wayland_transaction_apply_subsurface_position (surface, entry);
+
+      if (entry->state && entry->state->subsurface_placement_ops)
+        meta_wayland_surface_apply_placement_ops (surface, entry->state);
+    }
+
   /* Sort surfaces from ancestors to descendants */
   qsort (surfaces, num_surfaces, sizeof (MetaWaylandSurface *),
          meta_wayland_transaction_compare);
@@ -169,12 +183,10 @@ meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
   /* Apply states from ancestors to descendants */
   for (i = 0; i < num_surfaces; i++)
     {
-      MetaWaylandSurface *surface = surfaces[i];
-      MetaWaylandTransactionEntry *entry;
-
+      surface = surfaces[i];
       entry = meta_wayland_transaction_get_entry (transaction, surface);
+
       states[i] = entry->state;
-      meta_wayland_transaction_apply_subsurface_position (surface, entry);
       if (entry->state)
         meta_wayland_surface_apply_state (surface, entry->state);
 
@@ -314,7 +326,6 @@ meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
 
 static void
 meta_wayland_transaction_add_placement_surfaces (MetaWaylandTransaction  *transaction,
-                                                 MetaWaylandSurface      *surface,
                                                  MetaWaylandSurfaceState *state)
 {
   GSList *l;
@@ -323,8 +334,7 @@ meta_wayland_transaction_add_placement_surfaces (MetaWaylandTransaction  *transa
     {
       MetaWaylandSubsurfacePlacementOp *op = l->data;
 
-      if (op->surface)
-        meta_wayland_transaction_ensure_entry (transaction, op->surface);
+      meta_wayland_transaction_ensure_entry (transaction, op->surface);
 
       if (op->sibling)
         meta_wayland_transaction_ensure_entry (transaction, op->sibling);
@@ -339,10 +349,27 @@ meta_wayland_transaction_add_entry (MetaWaylandTransaction      *transaction,
   g_hash_table_insert (transaction->entries, g_object_ref (surface), entry);
 
   if (entry->state)
-    {
-      meta_wayland_transaction_add_placement_surfaces (transaction, surface,
-                                                       entry->state);
-    }
+    meta_wayland_transaction_add_placement_surfaces (transaction, entry->state);
+}
+
+void
+meta_wayland_transaction_add_placement_op (MetaWaylandTransaction           *transaction,
+                                           MetaWaylandSurface               *surface,
+                                           MetaWaylandSubsurfacePlacementOp *op)
+{
+  MetaWaylandTransactionEntry *entry;
+  MetaWaylandSurfaceState *state;
+
+  entry = meta_wayland_transaction_ensure_entry (transaction, surface);
+
+  if (!entry->state)
+    entry->state = meta_wayland_surface_state_new ();
+
+  state = entry->state;
+  state->subsurface_placement_ops =
+    g_slist_append (state->subsurface_placement_ops, op);
+
+  meta_wayland_transaction_add_placement_surfaces (transaction, state);
 }
 
 void
@@ -402,10 +429,7 @@ meta_wayland_transaction_merge_into (MetaWaylandTransaction *from,
         }
 
       if (from_entry->state)
-        {
-          meta_wayland_transaction_add_placement_surfaces (to, surface,
-                                                           from_entry->state);
-        }
+        meta_wayland_transaction_add_placement_surfaces (to, from_entry->state);
 
       meta_wayland_transaction_entry_merge_into (from_entry, to_entry);
       g_hash_table_iter_remove (&iter);
diff --git a/src/wayland/meta-wayland-transaction.h b/src/wayland/meta-wayland-transaction.h
index 720af1f56e..e05ff001ae 100644
--- a/src/wayland/meta-wayland-transaction.h
+++ b/src/wayland/meta-wayland-transaction.h
@@ -21,9 +21,14 @@
 #define META_WAYLAND_TRANSACTION_H
 
 #include "wayland/meta-wayland-types.h"
+#include "wayland/meta-wayland-subsurface.h"
 
 void meta_wayland_transaction_commit (MetaWaylandTransaction *transaction);
 
+void meta_wayland_transaction_add_placement_op (MetaWaylandTransaction           *transaction,
+                                                MetaWaylandSurface               *surface,
+                                                MetaWaylandSubsurfacePlacementOp *op);
+
 void meta_wayland_transaction_add_subsurface_position (MetaWaylandTransaction *transaction,
                                                        MetaWaylandSurface     *surface,
                                                        int                     x,
-- 
2.39.1


From 02864e9b75faf60133ca7e1147bfb511fe9df89f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Wed, 13 Jul 2022 17:10:05 +0200
Subject: [PATCH 18/27] wayland/surface: Call meta_wayland_buffer_attach from
 surface commit
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Preparation for potentially calling meta_wayland_transaction_apply some
time after surface commit, in which case doing it in the former would be
too late: The client may legally destroy the attached wl_buffer
immediately after commit, in which case meta_wayland_buffer_attach would
spuriously fail and disconnect the client (or possibly even crash mutter
due to NULL error).

Requires splitting up the surface texture between protocol and output
state, and propagating from the former to the latter via
MetaWaylandSurfaceState.

v2: (Jonas Ådahl)
* Move meta_wayland_surface_get_texture call to separate line.
* Use g_autoptr for GError.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-actor-surface.c |  4 +-
 src/wayland/meta-wayland-buffer.c        |  2 -
 src/wayland/meta-wayland-surface.c       | 76 ++++++++++++++----------
 src/wayland/meta-wayland-surface.h       |  4 +-
 4 files changed, 48 insertions(+), 38 deletions(-)

diff --git a/src/wayland/meta-wayland-actor-surface.c b/src/wayland/meta-wayland-actor-surface.c
index 87192825b0..bab5e20894 100644
--- a/src/wayland/meta-wayland-actor-surface.c
+++ b/src/wayland/meta-wayland-actor-surface.c
@@ -189,11 +189,13 @@ meta_wayland_actor_surface_real_sync_actor_state (MetaWaylandActorSurface *actor
     {
       CoglSnippet *snippet;
       gboolean is_y_inverted;
+      CoglTexture *texture;
 
       snippet = meta_wayland_buffer_create_snippet (buffer);
       is_y_inverted = meta_wayland_buffer_is_y_inverted (buffer);
 
-      meta_shaped_texture_set_texture (stex, surface->texture);
+      texture = meta_wayland_surface_get_texture (surface);
+      meta_shaped_texture_set_texture (stex, texture);
       meta_shaped_texture_set_snippet (stex, snippet);
       meta_shaped_texture_set_is_y_inverted (stex, is_y_inverted);
       meta_shaped_texture_set_buffer_scale (stex, surface->scale);
diff --git a/src/wayland/meta-wayland-buffer.c b/src/wayland/meta-wayland-buffer.c
index 910d5edc4f..bbf0ae2ad2 100644
--- a/src/wayland/meta-wayland-buffer.c
+++ b/src/wayland/meta-wayland-buffer.c
@@ -561,8 +561,6 @@ meta_wayland_buffer_attach (MetaWaylandBuffer  *buffer,
                             CoglTexture       **texture,
                             GError            **error)
 {
-  g_return_val_if_fail (buffer->resource, FALSE);
-
   COGL_TRACE_BEGIN_SCOPED (MetaWaylandBufferAttach, "WaylandBuffer (attach)");
 
   if (!meta_wayland_buffer_is_realized (buffer))
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index f5487936d3..31ffff1c51 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -311,7 +311,7 @@ get_buffer_width (MetaWaylandSurface *surface)
   MetaWaylandBuffer *buffer = meta_wayland_surface_get_buffer (surface);
 
   if (buffer)
-    return cogl_texture_get_width (surface->texture);
+    return cogl_texture_get_width (surface->output_state.texture);
   else
     return 0;
 }
@@ -322,7 +322,7 @@ get_buffer_height (MetaWaylandSurface *surface)
   MetaWaylandBuffer *buffer = meta_wayland_surface_get_buffer (surface);
 
   if (buffer)
-    return cogl_texture_get_height (surface->texture);
+    return cogl_texture_get_height (surface->output_state.texture);
   else
     return 0;
 }
@@ -418,7 +418,8 @@ surface_process_damage (MetaWaylandSurface *surface,
 
   cairo_region_intersect_rectangle (buffer_region, &buffer_rect);
 
-  meta_wayland_buffer_process_damage (buffer, surface->texture, buffer_region);
+  meta_wayland_buffer_process_damage (buffer, surface->output_state.texture,
+                                      buffer_region);
 
   actor = meta_wayland_surface_get_actor (surface);
   if (actor)
@@ -469,6 +470,7 @@ meta_wayland_surface_state_set_default (MetaWaylandSurfaceState *state)
 {
   state->newly_attached = FALSE;
   state->buffer = NULL;
+  state->texture = NULL;
   state->buffer_destroy_handler_id = 0;
   state->dx = 0;
   state->dy = 0;
@@ -514,6 +516,8 @@ meta_wayland_surface_state_clear (MetaWaylandSurfaceState *state)
 {
   MetaWaylandFrameCallback *cb, *next;
 
+  cogl_clear_object (&state->texture);
+
   g_clear_pointer (&state->surface_damage, cairo_region_destroy);
   g_clear_pointer (&state->buffer_damage, cairo_region_destroy);
   g_clear_pointer (&state->input_region, cairo_region_destroy);
@@ -549,6 +553,9 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
 
       to->newly_attached = TRUE;
       to->buffer = from->buffer;
+
+      cogl_clear_object (&to->texture);
+      to->texture = g_steal_pointer (&from->texture);
     }
 
   to->dx += from->dx;
@@ -799,30 +806,8 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
       if (state->buffer)
         meta_wayland_surface_ref_buffer_use_count (surface);
 
-      if (state->buffer)
-        {
-          GError *error = NULL;
-
-          if (!meta_wayland_buffer_attach (state->buffer,
-                                           &surface->texture,
-                                           &error))
-            {
-              g_warning ("Could not import pending buffer: %s", error->message);
-              if (surface->resource)
-                {
-                  wl_resource_post_error (surface->resource, WL_DISPLAY_ERROR_NO_MEMORY,
-                                          "Failed to attach buffer to surface %i: %s",
-                                          wl_resource_get_id (surface->resource),
-                                          error->message);
-                }
-              g_error_free (error);
-              goto cleanup;
-            }
-        }
-      else
-        {
-          cogl_clear_object (&surface->texture);
-        }
+      cogl_clear_object (&surface->output_state.texture);
+      surface->output_state.texture = g_steal_pointer (&state->texture);
 
       /* If the newly attached buffer is going to be accessed directly without
        * making a copy, such as an EGL buffer, mark it as in-use don't release
@@ -949,7 +934,6 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
   if (state->subsurface_placement_ops)
     meta_wayland_surface_notify_subsurface_state_changed (surface);
 
-cleanup:
   /* If we have a buffer that we are not using, decrease the use count so it may
    * be released if no-one else has a use-reference to it.
    */
@@ -1000,15 +984,39 @@ static void
 meta_wayland_surface_commit (MetaWaylandSurface *surface)
 {
   MetaWaylandSurfaceState *pending = surface->pending_state;
+  MetaWaylandBuffer *buffer = pending->buffer;
   MetaWaylandTransaction *transaction;
   MetaWaylandSurface *subsurface_surface;
 
   COGL_TRACE_BEGIN_SCOPED (MetaWaylandSurfaceCommit,
                            "WaylandSurface (commit)");
 
-  if (pending->buffer &&
-      !meta_wayland_buffer_is_realized (pending->buffer))
-    meta_wayland_buffer_realize (pending->buffer);
+  if (buffer)
+    {
+      g_autoptr (GError) error = NULL;
+
+      if (!meta_wayland_buffer_is_realized (buffer))
+        meta_wayland_buffer_realize (buffer);
+
+      if (!meta_wayland_buffer_attach (buffer,
+                                       &surface->protocol_state.texture,
+                                       &error))
+        {
+          g_warning ("Could not import pending buffer: %s", error->message);
+
+          wl_resource_post_error (surface->resource, WL_DISPLAY_ERROR_NO_MEMORY,
+                                  "Failed to attach buffer to surface %i: %s",
+                                  wl_resource_get_id (surface->resource),
+                                  error->message);
+          return;
+        }
+
+      pending->texture = cogl_object_ref (surface->protocol_state.texture);
+    }
+  else if (pending->newly_attached)
+    {
+      cogl_clear_object (&surface->protocol_state.texture);
+    }
 
   if (meta_wayland_surface_is_synchronized (surface))
     transaction = meta_wayland_surface_ensure_transaction (surface);
@@ -1483,7 +1491,7 @@ meta_wayland_surface_finalize (GObject *object)
 
   if (surface->buffer_held)
     meta_wayland_surface_unref_buffer_use_count (surface);
-  g_clear_pointer (&surface->texture, cogl_object_unref);
+  g_clear_pointer (&surface->output_state.texture, cogl_object_unref);
   g_clear_pointer (&surface->buffer_ref, meta_wayland_buffer_ref_unref);
 
   if (surface->opaque_region)
@@ -1535,6 +1543,8 @@ wl_surface_destructor (struct wl_resource *resource)
   g_clear_pointer (&surface->wl_subsurface, wl_resource_destroy);
   g_clear_pointer (&surface->protocol_state.subsurface_branch_node, g_node_destroy);
 
+  cogl_clear_object (&surface->protocol_state.texture);
+
   /*
    * Any transactions referencing this surface will keep it alive until they get
    * applied/destroyed. The last reference will be dropped in
@@ -2117,7 +2127,7 @@ meta_wayland_surface_is_shortcuts_inhibited (MetaWaylandSurface *surface,
 CoglTexture *
 meta_wayland_surface_get_texture (MetaWaylandSurface *surface)
 {
-  return surface->texture;
+  return surface->output_state.texture;
 }
 
 MetaSurfaceActor *
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 7aab3f2c7b..072d7f8eba 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -80,6 +80,7 @@ struct _MetaWaylandSurfaceState
   /* wl_surface.attach */
   gboolean newly_attached;
   MetaWaylandBuffer *buffer;
+  CoglTexture *texture;
   gulong buffer_destroy_handler_id;
   int32_t dx;
   int32_t dy;
@@ -169,8 +170,6 @@ struct _MetaWaylandSurface
   GHashTable *outputs;
   MetaMonitorTransform buffer_transform;
 
-  CoglTexture *texture;
-
   /* Buffer reference state. */
   MetaWaylandBufferRef *buffer_ref;
 
@@ -194,6 +193,7 @@ struct _MetaWaylandSurface
     MetaWaylandSurface *parent;
     GNode *subsurface_branch_node;
     GNode *subsurface_leaf_node;
+    CoglTexture *texture;
   } output_state, protocol_state;
 
   /* Extension resources. */
-- 
2.39.1


From 9ac5daec33832d8a4a7275987c8163b94c935429 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 1 Nov 2022 16:43:03 +0100
Subject: [PATCH 19/27] wayland/surface: Add role commit_state callback

Which gets called when pending state is committed for the surface.

This callback may amend the pending transaction or surface state as
needed.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-surface.c | 20 ++++++++++++++++++++
 src/wayland/meta-wayland-surface.h |  3 +++
 2 files changed, 23 insertions(+)

diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 31ffff1c51..7beb0ab609 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -114,6 +114,11 @@ guint surface_signals[N_SURFACE_SIGNALS] = { 0 };
 static void
 meta_wayland_surface_role_assigned (MetaWaylandSurfaceRole *surface_role);
 
+static void
+meta_wayland_surface_role_commit_state (MetaWaylandSurfaceRole  *surface_role,
+                                        MetaWaylandTransaction  *transaction,
+                                        MetaWaylandSurfaceState *pending);
+
 static void
 meta_wayland_surface_role_pre_apply_state (MetaWaylandSurfaceRole  *surface_role,
                                            MetaWaylandSurfaceState *pending);
@@ -1023,6 +1028,9 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
   else
     transaction = meta_wayland_transaction_new (surface->compositor);
 
+  if (surface->role)
+    meta_wayland_surface_role_commit_state (surface->role, transaction, pending);
+
   meta_wayland_transaction_merge_pending_state (transaction, surface);
 
   META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->protocol_state,
@@ -1952,6 +1960,18 @@ meta_wayland_surface_role_assigned (MetaWaylandSurfaceRole *surface_role)
   META_WAYLAND_SURFACE_ROLE_GET_CLASS (surface_role)->assigned (surface_role);
 }
 
+static void
+meta_wayland_surface_role_commit_state (MetaWaylandSurfaceRole  *surface_role,
+                                        MetaWaylandTransaction  *transaction,
+                                        MetaWaylandSurfaceState *pending)
+{
+  MetaWaylandSurfaceRoleClass *klass;
+
+  klass = META_WAYLAND_SURFACE_ROLE_GET_CLASS (surface_role);
+  if (klass->commit_state)
+    klass->commit_state (surface_role, transaction, pending);
+}
+
 static void
 meta_wayland_surface_role_pre_apply_state (MetaWaylandSurfaceRole  *surface_role,
                                            MetaWaylandSurfaceState *pending)
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 072d7f8eba..307038a2c9 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -54,6 +54,9 @@ struct _MetaWaylandSurfaceRoleClass
   GObjectClass parent_class;
 
   void (*assigned) (MetaWaylandSurfaceRole *surface_role);
+  void (*commit_state) (MetaWaylandSurfaceRole  *surface_role,
+                        MetaWaylandTransaction  *transaction,
+                        MetaWaylandSurfaceState *pending);
   void (*pre_apply_state) (MetaWaylandSurfaceRole  *surface_role,
                            MetaWaylandSurfaceState *pending);
   void (*apply_state) (MetaWaylandSurfaceRole  *surface_role,
-- 
2.39.1


From 26dcd04bbd6f5d3a1b79b72aa76b31c215be1eca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 1 Nov 2022 16:44:49 +0100
Subject: [PATCH 20/27] wayland/surface: Make
 meta_wayland_transaction_ensure_entry non-static

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-transaction.c | 6 +++---
 src/wayland/meta-wayland-transaction.h | 3 +++
 src/wayland/meta-wayland-types.h       | 1 +
 3 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 56aaf3923f..cc77ea663a 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -41,7 +41,7 @@ struct _MetaWaylandTransaction
   GHashTable *entries;
 };
 
-typedef struct _MetaWaylandTransactionEntry
+struct _MetaWaylandTransactionEntry
 {
   /* Next committed transaction with entry for the same surface */
   MetaWaylandTransaction *next_transaction;
@@ -52,7 +52,7 @@ typedef struct _MetaWaylandTransactionEntry
   gboolean has_sub_pos;
   int x;
   int y;
-} MetaWaylandTransactionEntry;
+};
 
 static MetaWaylandTransactionEntry *
 meta_wayland_transaction_get_entry (MetaWaylandTransaction *transaction,
@@ -301,7 +301,7 @@ meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
     meta_wayland_transaction_maybe_apply (transaction);
 }
 
-static MetaWaylandTransactionEntry *
+MetaWaylandTransactionEntry *
 meta_wayland_transaction_ensure_entry (MetaWaylandTransaction *transaction,
                                        MetaWaylandSurface     *surface)
 {
diff --git a/src/wayland/meta-wayland-transaction.h b/src/wayland/meta-wayland-transaction.h
index e05ff001ae..a42300f8e1 100644
--- a/src/wayland/meta-wayland-transaction.h
+++ b/src/wayland/meta-wayland-transaction.h
@@ -25,6 +25,9 @@
 
 void meta_wayland_transaction_commit (MetaWaylandTransaction *transaction);
 
+MetaWaylandTransactionEntry *meta_wayland_transaction_ensure_entry (MetaWaylandTransaction *transaction,
+                                                                    MetaWaylandSurface     *surface);
+
 void meta_wayland_transaction_add_placement_op (MetaWaylandTransaction           *transaction,
                                                 MetaWaylandSurface               *surface,
                                                 MetaWaylandSubsurfacePlacementOp *op);
diff --git a/src/wayland/meta-wayland-types.h b/src/wayland/meta-wayland-types.h
index c4db05b61e..97623df7f2 100644
--- a/src/wayland/meta-wayland-types.h
+++ b/src/wayland/meta-wayland-types.h
@@ -55,6 +55,7 @@ typedef struct _MetaWaylandSurface MetaWaylandSurface;
 typedef struct _MetaWaylandSurfaceState MetaWaylandSurfaceState;
 
 typedef struct _MetaWaylandTransaction MetaWaylandTransaction;
+typedef struct _MetaWaylandTransactionEntry MetaWaylandTransactionEntry;
 
 typedef struct _MetaWaylandOutput MetaWaylandOutput;
 
-- 
2.39.1


From 420d712061d9fb01e9fa31ac3e7a569584072ed0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 1 Nov 2022 16:52:41 +0100
Subject: [PATCH 21/27] wayland/xdg-shell: Add parent surface entry to popup
 setup transaction

This makes sure that finish_popup_setup is called after any previous
transactions for the parent surface have been applied, so the parent
window geometry is up to date.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-xdg-shell.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/src/wayland/meta-wayland-xdg-shell.c b/src/wayland/meta-wayland-xdg-shell.c
index bb68e5ecb5..1c2877d3ca 100644
--- a/src/wayland/meta-wayland-xdg-shell.c
+++ b/src/wayland/meta-wayland-xdg-shell.c
@@ -34,6 +34,7 @@
 #include "wayland/meta-wayland-seat.h"
 #include "wayland/meta-wayland-shell-surface.h"
 #include "wayland/meta-wayland-surface.h"
+#include "wayland/meta-wayland-transaction.h"
 #include "wayland/meta-wayland-versions.h"
 #include "wayland/meta-wayland-window-configuration.h"
 #include "wayland/meta-wayland.h"
@@ -1187,6 +1188,20 @@ dismiss_invalid_popup (MetaWaylandXdgPopup *xdg_popup)
     }
 }
 
+static void
+meta_wayland_xdg_popup_commit_state (MetaWaylandSurfaceRole  *surface_role,
+                                     MetaWaylandTransaction  *transaction,
+                                     MetaWaylandSurfaceState *pending)
+{
+  MetaWaylandXdgPopup *xdg_popup = META_WAYLAND_XDG_POPUP (surface_role);
+
+  if (xdg_popup->setup.parent_surface)
+    {
+      meta_wayland_transaction_ensure_entry (transaction,
+                                             xdg_popup->setup.parent_surface);
+    }
+}
+
 static void
 meta_wayland_xdg_popup_apply_state (MetaWaylandSurfaceRole  *surface_role,
                                     MetaWaylandSurfaceState *pending)
@@ -1447,6 +1462,7 @@ meta_wayland_xdg_popup_class_init (MetaWaylandXdgPopupClass *klass)
   object_class->finalize = meta_wayland_xdg_popup_finalize;
 
   surface_role_class = META_WAYLAND_SURFACE_ROLE_CLASS (klass);
+  surface_role_class->commit_state = meta_wayland_xdg_popup_commit_state;
   surface_role_class->apply_state = meta_wayland_xdg_popup_apply_state;
   surface_role_class->post_apply_state = meta_wayland_xdg_popup_post_apply_state;
   surface_role_class->get_toplevel = meta_wayland_xdg_popup_get_toplevel;
-- 
2.39.1


From b4bbd3c697acdf59915f65cda819e772629cd721 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 1 Nov 2022 17:30:00 +0100
Subject: [PATCH 22/27] wayland/xdg-shell: Defer
 meta_wayland_xdg_positioner_to_placement call
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

From xdg_surface_constructor_get_popup / xdg_popup_reposition (called
during Wayland protocol processing) to finish_popup_setup /
meta_wayland_xdg_popup_apply_state (called when the popup state is
applied).

This makes sure that the parent window frame rectangle is up to date in
meta_wayland_xdg_positioner_to_placement.

v2:
* Use meta_wayland_surface_state_new () in
  meta_wayland_transaction_add_xdg_popup_reposition.
v3:
* Move xdg_popup_repositioned handling to
  meta_wayland_xdg_popup_apply_state.
v4:
* Do not steal pending->xdg_positioner in
  meta_wayland_xdg_popup_apply_state, fixes leaking the corresponding
  memory.
* Drop MetaWaylandSurfaceState::xdg_popup_repositioned, just use
  ::xdg_positioner.
v5:
* Reformat meta_wayland_xdg_positioner_to_placement calls to stay within
  80 columns. (Jonas Ådahl)

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-surface.c     | 10 ++++
 src/wayland/meta-wayland-surface.h     |  4 ++
 src/wayland/meta-wayland-transaction.c | 21 ++++++++
 src/wayland/meta-wayland-transaction.h |  5 ++
 src/wayland/meta-wayland-types.h       |  2 +
 src/wayland/meta-wayland-xdg-shell.c   | 66 +++++++++++++++-----------
 6 files changed, 80 insertions(+), 28 deletions(-)

diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 7beb0ab609..c235ead1ce 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -502,6 +502,8 @@ meta_wayland_surface_state_set_default (MetaWaylandSurfaceState *state)
   state->subsurface_placement_ops = NULL;
 
   wl_list_init (&state->presentation_feedback_list);
+
+  state->xdg_popup_reposition_token = 0;
 }
 
 static void
@@ -527,6 +529,7 @@ meta_wayland_surface_state_clear (MetaWaylandSurfaceState *state)
   g_clear_pointer (&state->buffer_damage, cairo_region_destroy);
   g_clear_pointer (&state->input_region, cairo_region_destroy);
   g_clear_pointer (&state->opaque_region, cairo_region_destroy);
+  g_clear_pointer (&state->xdg_positioner, g_free);
 
   if (state->buffer)
     g_clear_signal_handler (&state->buffer_destroy_handler_id, state->buffer);
@@ -675,6 +678,13 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
   wl_list_insert_list (&to->presentation_feedback_list,
                        &from->presentation_feedback_list);
   wl_list_init (&from->presentation_feedback_list);
+
+  if (from->xdg_positioner)
+    {
+      g_clear_pointer (&to->xdg_positioner, g_free);
+      to->xdg_positioner = g_steal_pointer (&from->xdg_positioner);
+      to->xdg_popup_reposition_token = from->xdg_popup_reposition_token;
+    }
 }
 
 static void
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 307038a2c9..7edddf647f 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -133,6 +133,10 @@ struct _MetaWaylandSurfaceState
   struct {
     gboolean surface_size_changed;
   } derived;
+
+  /* xdg_popup */
+  MetaWaylandXdgPositioner *xdg_positioner;
+  uint32_t xdg_popup_reposition_token;
 };
 
 struct _MetaWaylandDragDestFuncs
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index cc77ea663a..6bf0376e9d 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -386,6 +386,27 @@ meta_wayland_transaction_add_subsurface_position (MetaWaylandTransaction *transa
   entry->has_sub_pos = TRUE;
 }
 
+void
+meta_wayland_transaction_add_xdg_popup_reposition (MetaWaylandTransaction *transaction,
+                                                   MetaWaylandSurface     *surface,
+                                                   void                   *xdg_positioner,
+                                                   uint32_t               token)
+{
+  MetaWaylandTransactionEntry *entry;
+  MetaWaylandSurfaceState *state;
+
+  entry = meta_wayland_transaction_ensure_entry (transaction, surface);
+
+  if (entry->state)
+    g_clear_pointer (&entry->state->xdg_positioner, g_free);
+  else
+    entry->state = meta_wayland_surface_state_new ();
+
+  state = entry->state;
+  state->xdg_positioner = xdg_positioner;
+  state->xdg_popup_reposition_token = token;
+}
+
 static void
 meta_wayland_transaction_entry_merge_into (MetaWaylandTransactionEntry *from,
                                            MetaWaylandTransactionEntry *to)
diff --git a/src/wayland/meta-wayland-transaction.h b/src/wayland/meta-wayland-transaction.h
index a42300f8e1..98c6620013 100644
--- a/src/wayland/meta-wayland-transaction.h
+++ b/src/wayland/meta-wayland-transaction.h
@@ -37,6 +37,11 @@ void meta_wayland_transaction_add_subsurface_position (MetaWaylandTransaction *t
                                                        int                     x,
                                                        int                     y);
 
+void meta_wayland_transaction_add_xdg_popup_reposition (MetaWaylandTransaction *transaction,
+                                                        MetaWaylandSurface     *surface,
+                                                        void                   *xdg_positioner,
+                                                        uint32_t               token);
+
 void meta_wayland_transaction_merge_into (MetaWaylandTransaction *from,
                                           MetaWaylandTransaction *to);
 
diff --git a/src/wayland/meta-wayland-types.h b/src/wayland/meta-wayland-types.h
index 97623df7f2..8b1c6f0079 100644
--- a/src/wayland/meta-wayland-types.h
+++ b/src/wayland/meta-wayland-types.h
@@ -67,6 +67,8 @@ typedef struct _MetaWaylandActivation MetaWaylandActivation;
 
 typedef struct _MetaWaylandDmaBufManager MetaWaylandDmaBufManager;
 
+typedef struct _MetaWaylandXdgPositioner MetaWaylandXdgPositioner;
+
 typedef struct _MetaXWaylandManager MetaXWaylandManager;
 
 #endif
diff --git a/src/wayland/meta-wayland-xdg-shell.c b/src/wayland/meta-wayland-xdg-shell.c
index 1c2877d3ca..2406482222 100644
--- a/src/wayland/meta-wayland-xdg-shell.c
+++ b/src/wayland/meta-wayland-xdg-shell.c
@@ -57,7 +57,7 @@ typedef struct _MetaWaylandXdgShellClient
   GList *surface_constructors;
 } MetaWaylandXdgShellClient;
 
-typedef struct _MetaWaylandXdgPositioner
+struct _MetaWaylandXdgPositioner
 {
   MetaRectangle anchor_rect;
   int32_t width;
@@ -76,7 +76,7 @@ typedef struct _MetaWaylandXdgPositioner
 
   gboolean acked_parent_configure;
   uint32_t parent_configure_serial;
-} MetaWaylandXdgPositioner;
+};
 
 typedef struct _MetaWaylandXdgSurfaceConstructor
 {
@@ -130,11 +130,7 @@ struct _MetaWaylandXdgPopup
   struct {
     MetaWaylandSurface *parent_surface;
 
-    /*
-     * The coordinates/dimensions in the placement rule are in logical pixel
-     * coordinate space, i.e. not scaled given what monitor the popup is on.
-     */
-    MetaPlacementRule placement_rule;
+    MetaWaylandXdgPositioner xdg_positioner;
 
     MetaWaylandSeat *grab_seat;
     uint32_t grab_serial;
@@ -623,27 +619,17 @@ xdg_popup_reposition (struct wl_client   *client,
     META_WAYLAND_SURFACE_ROLE (xdg_popup);
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
-  MetaWindow *window;
-  MetaWindow *parent_window;
   MetaWaylandXdgPositioner *xdg_positioner;
-  MetaPlacementRule placement_rule;
-
-  window = meta_wayland_surface_get_window (surface);
-  if (!window)
-    return;
-
-  parent_window = meta_wayland_surface_get_window (xdg_popup->parent_surface);
-
-  xdg_positioner = wl_resource_get_user_data (positioner_resource);
-  placement_rule = meta_wayland_xdg_positioner_to_placement (xdg_positioner,
-                                                             parent_window);
+  MetaWaylandTransaction *transaction;
 
-  xdg_popup->pending_reposition_token = token;
-  xdg_popup->pending_repositioned = TRUE;
+  xdg_positioner = g_memdup2 (wl_resource_get_user_data (positioner_resource),
+                              sizeof (MetaWaylandXdgPositioner));
 
-  scale_placement_rule (&placement_rule, surface);
-
-  meta_window_update_placement_rule (window, &placement_rule);
+  transaction = meta_wayland_transaction_new (surface->compositor);
+  meta_wayland_transaction_add_xdg_popup_reposition (transaction, surface,
+                                                     xdg_positioner, token);
+  meta_wayland_transaction_ensure_entry (transaction, xdg_popup->parent_surface);
+  meta_wayland_transaction_commit (transaction);
 }
 
 static const struct xdg_popup_interface meta_wayland_xdg_popup_interface = {
@@ -1080,6 +1066,8 @@ finish_popup_setup (MetaWaylandXdgPopup *xdg_popup)
   uint32_t serial;
   MetaDisplay *display = meta_get_display ();
   MetaWindow *window;
+  MetaWindow *parent_window;
+  MetaPlacementRule placement_rule;
 
   parent_surface = xdg_popup->setup.parent_surface;
   seat = xdg_popup->setup.grab_seat;
@@ -1124,7 +1112,11 @@ finish_popup_setup (MetaWaylandXdgPopup *xdg_popup)
   window = meta_window_wayland_new (display, surface);
   meta_wayland_shell_surface_set_window (shell_surface, window);
 
-  meta_wayland_xdg_popup_place (xdg_popup, &xdg_popup->setup.placement_rule);
+  parent_window = meta_wayland_surface_get_window (parent_surface);
+  placement_rule =
+    meta_wayland_xdg_positioner_to_placement (&xdg_popup->setup.xdg_positioner,
+                                              parent_window);
+  meta_wayland_xdg_popup_place (xdg_popup, &placement_rule);
 
   if (seat)
     {
@@ -1219,6 +1211,25 @@ meta_wayland_xdg_popup_apply_state (MetaWaylandSurfaceRole  *surface_role,
   if (xdg_popup->setup.parent_surface)
     finish_popup_setup (xdg_popup);
 
+  if (pending->xdg_positioner)
+    {
+      MetaWindow *window, *parent_window;
+      MetaPlacementRule placement_rule;
+
+      parent_window = meta_wayland_surface_get_window (xdg_popup->parent_surface);
+      placement_rule =
+        meta_wayland_xdg_positioner_to_placement (pending->xdg_positioner,
+                                                  parent_window);
+
+      xdg_popup->pending_reposition_token = pending->xdg_popup_reposition_token;
+      xdg_popup->pending_repositioned = TRUE;
+
+      scale_placement_rule (&placement_rule, surface);
+
+      window = meta_wayland_surface_get_window (surface);
+      meta_window_update_placement_rule (window, &placement_rule);
+    }
+
   if (!surface->buffer_ref->buffer && xdg_surface_priv->first_buffer_attached)
     {
       meta_wayland_xdg_surface_reset (xdg_surface);
@@ -2040,8 +2051,7 @@ xdg_surface_constructor_get_popup (struct wl_client   *client,
   meta_wayland_xdg_surface_constructor_finalize (constructor, xdg_surface);
 
   xdg_positioner = wl_resource_get_user_data (positioner_resource);
-  xdg_popup->setup.placement_rule =
-    meta_wayland_xdg_positioner_to_placement (xdg_positioner, parent_window);
+  xdg_popup->setup.xdg_positioner = *xdg_positioner;
   xdg_popup->setup.parent_surface = parent_surface;
 }
 
-- 
2.39.1


From 9adfc86014258c8c356c0cbdca0fde77f476eea5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 10 Jun 2022 18:49:29 +0200
Subject: [PATCH 23/27] wayland/surface: Defer meta_wayland_transaction_apply
 for dma-bufs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Until all dma-buf file descriptors for all buffers in the transaction
are readable, which corresponds to when the client drawing to the
buffers has finished.

This fixes https://gitlab.gnome.org/GNOME/mutter/-/issues/1162 if the
GPU & drivers support high priority contexts which can preempt lower
priority contexts.

v2:
* Also remove dma-buf fds from transaction and try applying it from
  pending_buffer_resource_destroyed. Avoids freeze due to leaving a
  GSource based on a closed fd attached if a client destroys a wl_buffer
  which is part of a transaction which was committed but not applied
  yet. (Robert Mader)
* Tweak transaction cleanup logic in wl_surface_destructor.
v3:
* Adapt to meta_wayland_dma_buf_get_source.
v4:
* Adapt to new commits using transactions for (sub-)surface destruction,
  drop code to remove destroyed surfaces from pending transactions.
v5:
* Use g_clear_pointer in meta_wayland_transaction_destroy.
  (Georges Basile Stavracas Neto)
* Add spaces between type casts and values. (Carlos Garnacho)
* Use (gpointer *) instead of (void**). (Carlos Garnacho)
* Use gpointer instead of void * in
  meta_wayland_transaction_dma_buf_dispatch.
v6:
* Use g_hash_table_remove in meta_wayland_transaction_dma_buf_dispatch.
  (Carlos Garnacho)
v7: (Jonas Ådahl)
* Move include of glib-unix.h below that of meta-wayland-transaction.h.
* Split up g_hash_table_iter_next call to multiple lines in
  meta_wayland_transaction_commit.
* Call g_source_destroy as well as g_source_unref when freeing a
  committed but not yet applied transaction (during mutter shutdown).
v8:
* Drop dma_buf_source_destroy, can use g_source_destroy directly.
  (Jonas Ådahl)

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-transaction.c | 77 +++++++++++++++++++++++++-
 1 file changed, 75 insertions(+), 2 deletions(-)

diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 6bf0376e9d..5ca4cf87d1 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -23,7 +23,10 @@
 
 #include "wayland/meta-wayland-transaction.h"
 
+#include <glib-unix.h>
+
 #include "wayland/meta-wayland.h"
+#include "wayland/meta-wayland-dma-buf.h"
 
 #define META_WAYLAND_TRANSACTION_NONE ((void *)(uintptr_t) G_MAXSIZE)
 
@@ -39,6 +42,9 @@ struct _MetaWaylandTransaction
    * Values: Pointer to MetaWaylandTransactionEntry for the surface
    */
   GHashTable *entries;
+
+  /* Sources for buffers which are not ready yet */
+  GHashTable *buf_sources;
 };
 
 struct _MetaWaylandTransactionEntry
@@ -161,6 +167,9 @@ meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
   MetaWaylandTransactionEntry *entry;
   int i;
 
+  if (g_hash_table_size (transaction->entries) == 0)
+    goto free;
+
   surfaces = (MetaWaylandSurface **)
     g_hash_table_get_keys_as_array (transaction->entries, &num_surfaces);
   states = g_new (MetaWaylandSurfaceState *, num_surfaces);
@@ -214,15 +223,20 @@ meta_wayland_transaction_apply (MetaWaylandTransaction  *transaction,
         meta_wayland_transaction_sync_child_states (surfaces[i]);
     }
 
+free:
   meta_wayland_transaction_free (transaction);
 }
 
 static gboolean
-has_unapplied_dependencies (MetaWaylandTransaction *transaction)
+has_dependencies (MetaWaylandTransaction *transaction)
 {
   GHashTableIter iter;
   MetaWaylandSurface *surface;
 
+  if (transaction->buf_sources &&
+      g_hash_table_size (transaction->buf_sources) > 0)
+    return TRUE;
+
   g_hash_table_iter_init (&iter, transaction->entries);
   while (g_hash_table_iter_next (&iter, (gpointer *) &surface, NULL))
     {
@@ -237,7 +251,7 @@ static void
 meta_wayland_transaction_maybe_apply_one (MetaWaylandTransaction  *transaction,
                                           MetaWaylandTransaction **first_candidate)
 {
-  if (has_unapplied_dependencies (transaction))
+  if (has_dependencies (transaction))
     return;
 
   meta_wayland_transaction_apply (transaction, first_candidate);
@@ -261,6 +275,49 @@ meta_wayland_transaction_maybe_apply (MetaWaylandTransaction *transaction)
     }
 }
 
+static void
+meta_wayland_transaction_dma_buf_dispatch (MetaWaylandBuffer *buffer,
+                                           gpointer           user_data)
+{
+  MetaWaylandTransaction *transaction = user_data;
+
+  if (!transaction->buf_sources ||
+      !g_hash_table_remove (transaction->buf_sources, buffer))
+    return;
+
+  meta_wayland_transaction_maybe_apply (transaction);
+}
+
+static gboolean
+meta_wayland_transaction_add_dma_buf_source (MetaWaylandTransaction *transaction,
+                                             MetaWaylandBuffer      *buffer)
+{
+  GSource *source;
+
+  if (transaction->buf_sources &&
+      g_hash_table_contains (transaction->buf_sources, buffer))
+    return FALSE;
+
+  source = meta_wayland_dma_buf_create_source (buffer,
+                                               meta_wayland_transaction_dma_buf_dispatch,
+                                               transaction);
+  if (!source)
+    return FALSE;
+
+  if (!transaction->buf_sources)
+    {
+      transaction->buf_sources =
+        g_hash_table_new_full (NULL, NULL, NULL,
+                               (GDestroyNotify) g_source_destroy);
+    }
+
+  g_hash_table_insert (transaction->buf_sources, buffer, source);
+  g_source_attach (source, NULL);
+  g_source_unref (source);
+
+  return TRUE;
+}
+
 void
 meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
 {
@@ -269,6 +326,21 @@ meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
   gboolean maybe_apply = TRUE;
   GHashTableIter iter;
   MetaWaylandSurface *surface;
+  MetaWaylandTransactionEntry *entry;
+
+  g_hash_table_iter_init (&iter, transaction->entries);
+  while (g_hash_table_iter_next (&iter,
+                                 (gpointer *) &surface, (gpointer *) &entry))
+    {
+      if (entry && entry->state)
+        {
+          MetaWaylandBuffer *buffer = entry->state->buffer;
+
+          if (buffer &&
+              meta_wayland_transaction_add_dma_buf_source (transaction, buffer))
+            maybe_apply = FALSE;
+        }
+    }
 
   transaction->committed_sequence = ++committed_sequence;
   transaction->node.data = transaction;
@@ -504,6 +576,7 @@ meta_wayland_transaction_free (MetaWaylandTransaction *transaction)
       g_queue_unlink (committed_queue, &transaction->node);
     }
 
+  g_clear_pointer (&transaction->buf_sources, g_hash_table_destroy);
   g_hash_table_destroy (transaction->entries);
   g_free (transaction);
 }
-- 
2.39.1


From bfda0becc6a5ea26388377960a78ed214b94f126 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Wed, 22 Jun 2022 18:43:11 +0200
Subject: [PATCH 24/27] wayland/surface: Overhaul handling of buffer use count

Move the use count from a separate MetaWaylandBufferRef struct to the
MetaWaylandBuffer class, and remove the former.

The buffer use count is now incremented already in
meta_wayland_surface_commit, since the Wayland protocol defines the
buffer to be in use by the compositor at that point. If the buffer
attachment ends up being dropped again before it is applied to the
surface state (e.g. because another buffer is committed to a
synchronized sub-surface before the parent surface is committed),
the use count is now decremented, and a buffer release event is sent if
the use count drops to 0.

Buffer release events were previously incorrectly not sent under these
circumstances. Test case: Run the weston-subsurfaces demo with the -r1
and/or -t1 command line parameter. Resize the window. Before this
change, weston-subsurfaces would freeze or abort after a few resize
operations, because mutter failed to send release events and the
client ran out of usable buffers.

v2:
* Handle NULL priv->buffer_ref in
  meta_wayland_cursor_surface_apply_state.
v3:
* Remove MetaWaylandBufferRef altogether, move the use count tracking
  to MetaWaylandBuffer itself. Much simpler, and doesn't run into
  lifetime issues when mutter shuts down.
v4:
* Warn if use count isn't 0 in meta_wayland_buffer_finalize.
* Keep pending_buffer_resource_destroyed for attached but not yet
  committed buffers. If the client attaches a buffer and then destroys
  it before commit, we ignore the buffer attachement, same as before
  this MR.
v5:
* Rebase on top of new commit which splits up surface->texture.
* MetaWaylandSurfaceState::buffer can only be non-NULL if
  ::newly_attached is TRUE, simplify accordingly.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1880>
---
 src/wayland/meta-wayland-actor-surface.c  |   2 +-
 src/wayland/meta-wayland-buffer.c         |  21 +++
 src/wayland/meta-wayland-buffer.h         |   4 +
 src/wayland/meta-wayland-cursor-surface.c |  22 +--
 src/wayland/meta-wayland-shell-surface.c  |   2 +-
 src/wayland/meta-wayland-subsurface.c     |   4 +-
 src/wayland/meta-wayland-surface.c        | 165 +++++++---------------
 src/wayland/meta-wayland-surface.h        |  13 +-
 src/wayland/meta-wayland-transaction.c    |  10 +-
 src/wayland/meta-wayland-xdg-shell.c      |  14 +-
 src/wayland/meta-xwayland-surface.c       |   2 +-
 11 files changed, 102 insertions(+), 157 deletions(-)

diff --git a/src/wayland/meta-wayland-actor-surface.c b/src/wayland/meta-wayland-actor-surface.c
index bab5e20894..a00ab4361e 100644
--- a/src/wayland/meta-wayland-actor-surface.c
+++ b/src/wayland/meta-wayland-actor-surface.c
@@ -184,7 +184,7 @@ meta_wayland_actor_surface_real_sync_actor_state (MetaWaylandActorSurface *actor
   surface_actor = priv->actor;
   stex = meta_surface_actor_get_texture (surface_actor);
 
-  buffer = surface->buffer_ref->buffer;
+  buffer = meta_wayland_surface_get_buffer (surface);
   if (buffer)
     {
       CoglSnippet *snippet;
diff --git a/src/wayland/meta-wayland-buffer.c b/src/wayland/meta-wayland-buffer.c
index bbf0ae2ad2..0aa0326146 100644
--- a/src/wayland/meta-wayland-buffer.c
+++ b/src/wayland/meta-wayland-buffer.c
@@ -621,6 +621,25 @@ meta_wayland_buffer_create_snippet (MetaWaylandBuffer *buffer)
 #endif /* HAVE_WAYLAND_EGLSTREAM */
 }
 
+void
+meta_wayland_buffer_inc_use_count (MetaWaylandBuffer *buffer)
+{
+  g_warn_if_fail (buffer->resource);
+
+  buffer->use_count++;
+}
+
+void
+meta_wayland_buffer_dec_use_count (MetaWaylandBuffer *buffer)
+{
+  g_return_if_fail (buffer->use_count > 0);
+
+  buffer->use_count--;
+
+  if (buffer->use_count == 0 && buffer->resource)
+    wl_buffer_send_release (buffer->resource);
+}
+
 gboolean
 meta_wayland_buffer_is_y_inverted (MetaWaylandBuffer *buffer)
 {
@@ -804,6 +823,8 @@ meta_wayland_buffer_finalize (GObject *object)
 {
   MetaWaylandBuffer *buffer = META_WAYLAND_BUFFER (object);
 
+  g_warn_if_fail (buffer->use_count == 0);
+
   g_clear_pointer (&buffer->egl_image.texture, cogl_object_unref);
 #ifdef HAVE_WAYLAND_EGLSTREAM
   g_clear_pointer (&buffer->egl_stream.texture, cogl_object_unref);
diff --git a/src/wayland/meta-wayland-buffer.h b/src/wayland/meta-wayland-buffer.h
index 0f83b67de1..f0f352d71e 100644
--- a/src/wayland/meta-wayland-buffer.h
+++ b/src/wayland/meta-wayland-buffer.h
@@ -54,6 +54,8 @@ struct _MetaWaylandBuffer
   struct wl_resource *resource;
   struct wl_listener destroy_listener;
 
+  unsigned int use_count;
+
   gboolean is_y_inverted;
 
   MetaWaylandBufferType type;
@@ -93,6 +95,8 @@ gboolean                meta_wayland_buffer_attach              (MetaWaylandBuff
                                                                  CoglTexture          **texture,
                                                                  GError               **error);
 CoglSnippet *           meta_wayland_buffer_create_snippet      (MetaWaylandBuffer     *buffer);
+void                    meta_wayland_buffer_inc_use_count       (MetaWaylandBuffer     *buffer);
+void                    meta_wayland_buffer_dec_use_count       (MetaWaylandBuffer     *buffer);
 gboolean                meta_wayland_buffer_is_y_inverted       (MetaWaylandBuffer     *buffer);
 void                    meta_wayland_buffer_process_damage      (MetaWaylandBuffer     *buffer,
                                                                  CoglTexture           *texture,
diff --git a/src/wayland/meta-wayland-cursor-surface.c b/src/wayland/meta-wayland-cursor-surface.c
index 4d3b7547c5..9d045c18ad 100644
--- a/src/wayland/meta-wayland-cursor-surface.c
+++ b/src/wayland/meta-wayland-cursor-surface.c
@@ -139,12 +139,10 @@ meta_wayland_cursor_surface_pre_apply_state (MetaWaylandSurfaceRole  *surface_ro
     META_WAYLAND_CURSOR_SURFACE (surface_role);
   MetaWaylandCursorSurfacePrivate *priv =
     meta_wayland_cursor_surface_get_instance_private (cursor_surface);
-  MetaWaylandSurface *surface =
-    meta_wayland_surface_role_get_surface (surface_role);
 
   if (pending->newly_attached && priv->buffer)
     {
-      meta_wayland_surface_unref_buffer_use_count (surface);
+      meta_wayland_buffer_dec_use_count (priv->buffer);
       g_clear_object (&priv->buffer);
     }
 }
@@ -157,15 +155,11 @@ meta_wayland_cursor_surface_apply_state (MetaWaylandSurfaceRole  *surface_role,
     META_WAYLAND_CURSOR_SURFACE (surface_role);
   MetaWaylandCursorSurfacePrivate *priv =
     meta_wayland_cursor_surface_get_instance_private (cursor_surface);
-  MetaWaylandSurface *surface =
-    meta_wayland_surface_role_get_surface (surface_role);
-  MetaWaylandBuffer *buffer = meta_wayland_surface_get_buffer (surface);
 
-  if (pending->newly_attached)
+  if (pending->buffer)
     {
-      g_set_object (&priv->buffer, buffer);
-      if (priv->buffer)
-        meta_wayland_surface_ref_buffer_use_count (surface);
+      priv->buffer = g_object_ref (pending->buffer);
+      meta_wayland_buffer_inc_use_count (priv->buffer);
     }
 
   wl_list_insert_list (&priv->frame_callbacks,
@@ -213,8 +207,6 @@ meta_wayland_cursor_surface_dispose (GObject *object)
     META_WAYLAND_CURSOR_SURFACE (object);
   MetaWaylandCursorSurfacePrivate *priv =
     meta_wayland_cursor_surface_get_instance_private (cursor_surface);
-  MetaWaylandSurface *surface =
-    meta_wayland_surface_role_get_surface (META_WAYLAND_SURFACE_ROLE (object));
   MetaWaylandFrameCallback *cb, *next;
 
   wl_list_for_each_safe (cb, next, &priv->frame_callbacks, link)
@@ -234,7 +226,7 @@ meta_wayland_cursor_surface_dispose (GObject *object)
 
   if (priv->buffer)
     {
-      meta_wayland_surface_unref_buffer_use_count (surface);
+      meta_wayland_buffer_dec_use_count (priv->buffer);
       g_clear_object (&priv->buffer);
     }
 
@@ -263,8 +255,8 @@ meta_wayland_cursor_surface_constructed (GObject *object)
 
   if (buffer && buffer->resource)
     {
-      g_set_object (&priv->buffer, buffer);
-      meta_wayland_surface_ref_buffer_use_count (surface);
+      priv->buffer = g_object_ref (surface->buffer);
+      meta_wayland_buffer_inc_use_count (priv->buffer);
     }
 
   priv->cursor_sprite = meta_cursor_sprite_wayland_new (surface,
diff --git a/src/wayland/meta-wayland-shell-surface.c b/src/wayland/meta-wayland-shell-surface.c
index a98101a593..46a3426cf1 100644
--- a/src/wayland/meta-wayland-shell-surface.c
+++ b/src/wayland/meta-wayland-shell-surface.c
@@ -215,7 +215,7 @@ meta_wayland_shell_surface_surface_pre_apply_state (MetaWaylandSurfaceRole  *sur
     meta_wayland_surface_role_get_surface (surface_role);
 
   if (pending->newly_attached &&
-      !surface->buffer_ref->buffer &&
+      !surface->buffer &&
       priv->window)
     meta_window_queue (priv->window, META_QUEUE_CALC_SHOWING);
 }
diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index d86e66ab0b..63150d006f 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -58,7 +58,7 @@ transform_subsurface_position (MetaWaylandSurface *surface,
 static gboolean
 should_show (MetaWaylandSurface *surface)
 {
-  if (!surface->buffer_ref->buffer)
+  if (!surface->buffer)
     return FALSE;
   else if (surface->output_state.parent)
     return should_show (surface->output_state.parent);
@@ -126,7 +126,7 @@ meta_wayland_subsurface_union_geometry (MetaWaylandSubsurface *subsurface,
     .height = meta_wayland_surface_get_height (surface),
   };
 
-  if (surface->buffer_ref->buffer)
+  if (surface->buffer)
     meta_rectangle_union (out_geometry, &geometry, out_geometry);
 
   META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->output_state,
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index c235ead1ce..d5121fb6f9 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -143,58 +143,6 @@ set_surface_is_on_output (MetaWaylandSurface *surface,
                           MetaWaylandOutput  *wayland_output,
                           gboolean            is_on_output);
 
-static MetaWaylandBufferRef *
-meta_wayland_buffer_ref_new (void)
-{
-  MetaWaylandBufferRef *buffer_ref;
-
-  buffer_ref = g_new0 (MetaWaylandBufferRef, 1);
-  g_ref_count_init (&buffer_ref->ref_count);
-
-  return buffer_ref;
-}
-
-static MetaWaylandBufferRef *
-meta_wayland_buffer_ref_ref (MetaWaylandBufferRef *buffer_ref)
-{
-  g_ref_count_inc (&buffer_ref->ref_count);
-  return buffer_ref;
-}
-
-static void
-meta_wayland_buffer_ref_unref (MetaWaylandBufferRef *buffer_ref)
-{
-  if (g_ref_count_dec (&buffer_ref->ref_count))
-    {
-      g_warn_if_fail (buffer_ref->use_count == 0);
-      g_clear_object (&buffer_ref->buffer);
-      g_free (buffer_ref);
-    }
-}
-
-static void
-meta_wayland_buffer_ref_inc_use_count (MetaWaylandBufferRef *buffer_ref)
-{
-  g_return_if_fail (buffer_ref->buffer);
-  g_warn_if_fail (buffer_ref->buffer->resource);
-
-  buffer_ref->use_count++;
-}
-
-static void
-meta_wayland_buffer_ref_dec_use_count (MetaWaylandBufferRef *buffer_ref)
-{
-  MetaWaylandBuffer *buffer = buffer_ref->buffer;
-
-  g_return_if_fail (buffer_ref->use_count > 0);
-  g_return_if_fail (buffer);
-
-  buffer_ref->use_count--;
-
-  if (buffer_ref->use_count == 0 && buffer->resource)
-    wl_buffer_send_release (buffer->resource);
-}
-
 static void
 role_assignment_valist_to_properties (GType       role_type,
                                       const char *first_property_name,
@@ -287,7 +235,7 @@ meta_wayland_surface_assign_role (MetaWaylandSurface *surface,
       /* Release the use count held on behalf of the just assigned role. */
       if (surface->unassigned.buffer)
         {
-          meta_wayland_surface_unref_buffer_use_count (surface);
+          meta_wayland_buffer_dec_use_count (surface->unassigned.buffer);
           g_clear_object (&surface->unassigned.buffer);
         }
 
@@ -447,19 +395,7 @@ surface_process_damage (MetaWaylandSurface *surface,
 MetaWaylandBuffer *
 meta_wayland_surface_get_buffer (MetaWaylandSurface *surface)
 {
-  return surface->buffer_ref->buffer;
-}
-
-void
-meta_wayland_surface_ref_buffer_use_count (MetaWaylandSurface *surface)
-{
-  meta_wayland_buffer_ref_inc_use_count (surface->buffer_ref);
-}
-
-void
-meta_wayland_surface_unref_buffer_use_count (MetaWaylandSurface *surface)
-{
-  meta_wayland_buffer_ref_dec_use_count (surface->buffer_ref);
+  return surface->buffer;
 }
 
 static void
@@ -531,8 +467,15 @@ meta_wayland_surface_state_clear (MetaWaylandSurfaceState *state)
   g_clear_pointer (&state->opaque_region, cairo_region_destroy);
   g_clear_pointer (&state->xdg_positioner, g_free);
 
-  if (state->buffer)
-    g_clear_signal_handler (&state->buffer_destroy_handler_id, state->buffer);
+  if (state->buffer_destroy_handler_id)
+    {
+      g_clear_signal_handler (&state->buffer_destroy_handler_id, state->buffer);
+      state->buffer = NULL;
+    }
+  else
+    {
+      g_clear_object (&state->buffer);
+    }
 
   wl_list_for_each_safe (cb, next, &state->frame_callback_list, link)
     wl_resource_destroy (cb->resource);
@@ -557,10 +500,14 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
   if (from->newly_attached)
     {
       if (to->buffer)
-        g_clear_signal_handler (&to->buffer_destroy_handler_id, to->buffer);
+        {
+          g_warn_if_fail (to->buffer_destroy_handler_id == 0);
+          meta_wayland_buffer_dec_use_count (to->buffer);
+          g_object_unref (to->buffer);
+        }
 
       to->newly_attached = TRUE;
-      to->buffer = from->buffer;
+      to->buffer = g_steal_pointer (&from->buffer);
 
       cogl_clear_object (&to->texture);
       to->texture = g_steal_pointer (&from->texture);
@@ -646,14 +593,6 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
       to->has_new_viewport_dst_size = TRUE;
     }
 
-  if (to->buffer && to->buffer_destroy_handler_id == 0)
-    {
-      to->buffer_destroy_handler_id =
-        g_signal_connect (to->buffer, "resource-destroyed",
-                          G_CALLBACK (pending_buffer_resource_destroyed),
-                          to);
-    }
-
   if (from->subsurface_placement_ops != NULL)
     {
       if (to->subsurface_placement_ops != NULL)
@@ -795,7 +734,7 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
     {
       if (state->newly_attached && surface->unassigned.buffer)
         {
-          meta_wayland_surface_unref_buffer_use_count (surface);
+          meta_wayland_buffer_dec_use_count (surface->unassigned.buffer);
           g_clear_object (&surface->unassigned.buffer);
         }
     }
@@ -808,19 +747,9 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
        * is symmetric.
        */
       if (surface->buffer_held)
-        meta_wayland_surface_unref_buffer_use_count (surface);
-
-      if (surface->buffer_ref->use_count > 0)
-        {
-          meta_wayland_buffer_ref_unref (surface->buffer_ref);
-          surface->buffer_ref = meta_wayland_buffer_ref_new ();
-        }
-
-      g_set_object (&surface->buffer_ref->buffer, state->buffer);
-
-      if (state->buffer)
-        meta_wayland_surface_ref_buffer_use_count (surface);
+        meta_wayland_buffer_dec_use_count (surface->buffer);
 
+      g_set_object (&surface->buffer, state->buffer);
       cogl_clear_object (&surface->output_state.texture);
       surface->output_state.texture = g_steal_pointer (&state->texture);
 
@@ -933,28 +862,26 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
                            &state->frame_callback_list);
       wl_list_init (&state->frame_callback_list);
 
-      if (state->newly_attached)
+      if (state->buffer)
         {
           /* The need to keep the wl_buffer from being released depends on what
            * role the surface is given. That means we need to also keep a use
            * count for wl_buffer's that are used by unassigned wl_surface's.
            */
-          g_set_object (&surface->unassigned.buffer,
-                        surface->buffer_ref->buffer);
-          if (surface->unassigned.buffer)
-            meta_wayland_surface_ref_buffer_use_count (surface);
+          surface->unassigned.buffer = g_object_ref (state->buffer);
+          meta_wayland_buffer_inc_use_count (surface->unassigned.buffer);
         }
     }
 
   if (state->subsurface_placement_ops)
     meta_wayland_surface_notify_subsurface_state_changed (surface);
 
-  /* If we have a buffer that we are not using, decrease the use count so it may
-   * be released if no-one else has a use-reference to it.
+  /* If we need to hold the newly attached buffer, drop its reference from the
+   * state, to prevent meta_wayland_transaction_entry_destroy from decreasing
+   * the use count.
    */
-  if (state->newly_attached &&
-      !surface->buffer_held && surface->buffer_ref->buffer)
-    meta_wayland_surface_unref_buffer_use_count (surface);
+  if (state->newly_attached && surface->buffer_held)
+    g_clear_object (&state->buffer);
 
   g_signal_emit (state,
                  surface_state_signals[SURFACE_STATE_SIGNAL_APPLIED],
@@ -1010,6 +937,9 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
     {
       g_autoptr (GError) error = NULL;
 
+      g_clear_signal_handler (&pending->buffer_destroy_handler_id,
+                              buffer);
+
       if (!meta_wayland_buffer_is_realized (buffer))
         meta_wayland_buffer_realize (buffer);
 
@@ -1027,6 +957,9 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
         }
 
       pending->texture = cogl_object_ref (surface->protocol_state.texture);
+
+      g_object_ref (buffer);
+      meta_wayland_buffer_inc_use_count (buffer);
     }
   else if (pending->newly_attached)
     {
@@ -1503,14 +1436,14 @@ meta_wayland_surface_finalize (GObject *object)
 
   if (surface->unassigned.buffer)
     {
-      meta_wayland_surface_unref_buffer_use_count (surface);
+      meta_wayland_buffer_dec_use_count (surface->unassigned.buffer);
       g_clear_object (&surface->unassigned.buffer);
     }
 
   if (surface->buffer_held)
-    meta_wayland_surface_unref_buffer_use_count (surface);
+    meta_wayland_buffer_dec_use_count (surface->buffer);
   g_clear_pointer (&surface->output_state.texture, cogl_object_unref);
-  g_clear_pointer (&surface->buffer_ref, meta_wayland_buffer_ref_unref);
+  g_clear_object (&surface->buffer);
 
   if (surface->opaque_region)
     cairo_region_destroy (surface->opaque_region);
@@ -1796,8 +1729,6 @@ meta_wayland_surface_init (MetaWaylandSurface *surface)
 {
   surface->pending_state = meta_wayland_surface_state_new ();
 
-  surface->buffer_ref = meta_wayland_buffer_ref_new ();
-
   surface->output_state.subsurface_branch_node = g_node_new (surface);
   surface->output_state.subsurface_leaf_node =
     g_node_prepend_data (surface->output_state.subsurface_branch_node, surface);
@@ -2113,7 +2044,7 @@ meta_wayland_surface_calculate_input_region (MetaWaylandSurface *surface)
   cairo_region_t *region;
   cairo_rectangle_int_t buffer_rect;
 
-  if (!surface->buffer_ref->buffer)
+  if (!surface->buffer)
     return NULL;
 
   buffer_rect = (cairo_rectangle_int_t) {
@@ -2227,10 +2158,10 @@ static void
 scanout_destroyed (gpointer  data,
                    GObject  *where_the_object_was)
 {
-  MetaWaylandBufferRef *buffer_ref = data;
+  MetaWaylandBuffer *buffer = data;
 
-  meta_wayland_buffer_ref_dec_use_count (buffer_ref);
-  meta_wayland_buffer_ref_unref (buffer_ref);
+  meta_wayland_buffer_dec_use_count (buffer);
+  g_object_unref (buffer);
 }
 
 CoglScanout *
@@ -2238,22 +2169,22 @@ meta_wayland_surface_try_acquire_scanout (MetaWaylandSurface *surface,
                                           CoglOnscreen       *onscreen)
 {
   CoglScanout *scanout;
-  MetaWaylandBufferRef *buffer_ref;
+  MetaWaylandBuffer *buffer;
 
-  if (!surface->buffer_ref->buffer)
+  if (!surface->buffer)
     return NULL;
 
-  if (surface->buffer_ref->use_count == 0)
+  if (surface->buffer->use_count == 0)
     return NULL;
 
-  scanout = meta_wayland_buffer_try_acquire_scanout (surface->buffer_ref->buffer,
+  scanout = meta_wayland_buffer_try_acquire_scanout (surface->buffer,
                                                      onscreen);
   if (!scanout)
     return NULL;
 
-  buffer_ref = meta_wayland_buffer_ref_ref (surface->buffer_ref);
-  meta_wayland_buffer_ref_inc_use_count (buffer_ref);
-  g_object_weak_ref (G_OBJECT (scanout), scanout_destroyed, buffer_ref);
+  buffer = g_object_ref (surface->buffer);
+  meta_wayland_buffer_inc_use_count (buffer);
+  g_object_weak_ref (G_OBJECT (scanout), scanout_destroyed, buffer);
 
   return scanout;
 }
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 7edddf647f..9ba5264757 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -155,13 +155,6 @@ struct _MetaWaylandDragDestFuncs
                       MetaWaylandSurface    *surface);
 };
 
-typedef struct _MetaWaylandBufferRef
-{
-  grefcount ref_count;
-  MetaWaylandBuffer *buffer;
-  unsigned int use_count;
-} MetaWaylandBufferRef;
-
 struct _MetaWaylandSurface
 {
   GObject parent;
@@ -178,7 +171,7 @@ struct _MetaWaylandSurface
   MetaMonitorTransform buffer_transform;
 
   /* Buffer reference state. */
-  MetaWaylandBufferRef *buffer_ref;
+  MetaWaylandBuffer *buffer;
 
   /* Buffer renderer state. */
   gboolean buffer_held;
@@ -301,10 +294,6 @@ gboolean            meta_wayland_surface_assign_role (MetaWaylandSurface *surfac
 
 MetaWaylandBuffer  *meta_wayland_surface_get_buffer (MetaWaylandSurface *surface);
 
-void                meta_wayland_surface_ref_buffer_use_count (MetaWaylandSurface *surface);
-
-void                meta_wayland_surface_unref_buffer_use_count (MetaWaylandSurface *surface);
-
 void                meta_wayland_surface_set_window (MetaWaylandSurface *surface,
                                                      MetaWindow         *window);
 
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 5ca4cf87d1..7b9a5e9fe4 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -26,6 +26,7 @@
 #include <glib-unix.h>
 
 #include "wayland/meta-wayland.h"
+#include "wayland/meta-wayland-buffer.h"
 #include "wayland/meta-wayland-dma-buf.h"
 
 #define META_WAYLAND_TRANSACTION_NONE ((void *)(uintptr_t) G_MAXSIZE)
@@ -392,7 +393,14 @@ meta_wayland_transaction_ensure_entry (MetaWaylandTransaction *transaction,
 static void
 meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
 {
-  g_clear_object (&entry->state);
+  if (entry->state)
+    {
+      if (entry->state->buffer)
+        meta_wayland_buffer_dec_use_count (entry->state->buffer);
+
+      g_clear_object (&entry->state);
+    }
+
   g_free (entry);
 }
 
diff --git a/src/wayland/meta-wayland-xdg-shell.c b/src/wayland/meta-wayland-xdg-shell.c
index 2406482222..8227bd12da 100644
--- a/src/wayland/meta-wayland-xdg-shell.c
+++ b/src/wayland/meta-wayland-xdg-shell.c
@@ -783,7 +783,7 @@ meta_wayland_xdg_toplevel_apply_state (MetaWaylandSurfaceRole  *surface_role,
       return;
     }
 
-  if (!surface->buffer_ref->buffer && xdg_surface_priv->first_buffer_attached)
+  if (!surface->buffer && xdg_surface_priv->first_buffer_attached)
     {
       meta_wayland_xdg_surface_reset (xdg_surface);
       meta_wayland_actor_surface_queue_frame_callbacks (actor_surface,
@@ -1230,7 +1230,7 @@ meta_wayland_xdg_popup_apply_state (MetaWaylandSurfaceRole  *surface_role,
       meta_window_update_placement_rule (window, &placement_rule);
     }
 
-  if (!surface->buffer_ref->buffer && xdg_surface_priv->first_buffer_attached)
+  if (!surface->buffer && xdg_surface_priv->first_buffer_attached)
     {
       meta_wayland_xdg_surface_reset (xdg_surface);
       meta_wayland_actor_surface_queue_frame_callbacks (actor_surface, pending);
@@ -1241,7 +1241,7 @@ meta_wayland_xdg_popup_apply_state (MetaWaylandSurfaceRole  *surface_role,
     META_WAYLAND_SURFACE_ROLE_CLASS (meta_wayland_xdg_popup_parent_class);
   surface_role_class->apply_state (surface_role, pending);
 
-  if (xdg_popup->dismissed_by_client && surface->buffer_ref->buffer)
+  if (xdg_popup->dismissed_by_client && surface->buffer)
     {
       wl_resource_post_error (xdg_popup->resource,
                               XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
@@ -1273,7 +1273,7 @@ meta_wayland_xdg_popup_post_apply_state (MetaWaylandSurfaceRole  *surface_role,
   if (!window)
     return;
 
-  if (!surface->buffer_ref->buffer)
+  if (!surface->buffer)
     return;
 
   surface_role_class->post_apply_state (surface_role, pending);
@@ -1693,7 +1693,7 @@ meta_wayland_xdg_surface_apply_state (MetaWaylandSurfaceRole  *surface_role,
   if (!window)
     return;
 
-  if (surface->buffer_ref->buffer)
+  if (surface->buffer)
     priv->first_buffer_attached = TRUE;
 }
 
@@ -1755,7 +1755,7 @@ meta_wayland_xdg_surface_assigned (MetaWaylandSurfaceRole *surface_role)
   priv->configure_sent = FALSE;
   priv->first_buffer_attached = FALSE;
 
-  if (surface->buffer_ref->buffer)
+  if (surface->buffer)
     {
       wl_resource_post_error (xdg_wm_base_resource,
                               XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
@@ -2460,7 +2460,7 @@ xdg_wm_base_get_xdg_surface (struct wl_client   *client,
       return;
     }
 
-  if (surface->buffer_ref->buffer)
+  if (surface->buffer)
     {
       wl_resource_post_error (resource,
                               XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
diff --git a/src/wayland/meta-xwayland-surface.c b/src/wayland/meta-xwayland-surface.c
index 54db84470f..c5f32a02e3 100644
--- a/src/wayland/meta-xwayland-surface.c
+++ b/src/wayland/meta-xwayland-surface.c
@@ -148,7 +148,7 @@ meta_xwayland_surface_pre_apply_state (MetaWaylandSurfaceRole  *surface_role,
   MetaXwaylandSurface *xwayland_surface = META_XWAYLAND_SURFACE (surface_role);
 
   if (pending->newly_attached &&
-      !surface->buffer_ref->buffer &&
+      !surface->buffer &&
       xwayland_surface->window)
     meta_window_queue (xwayland_surface->window, META_QUEUE_CALC_SHOWING);
 }
-- 
2.39.1


From 2d14e3fd10f0603354c02a888043e5727d826c30 Mon Sep 17 00:00:00 2001
From: Robert Mader <robert.mader@collabora.com>
Date: Wed, 2 Nov 2022 19:35:35 +0100
Subject: [PATCH 25/27] wayland/subsurface: Implement
 meta_wayland_surface_get_window()

Subsurfaces are special regarding windows as they don't have a window,
but usually have an ancestor which does. All current users of
`get_window()` are either used for known surface roles, such as xdg-*
ones, or, as is the case for pointer constrains, would actually want to
get the ancestors window.

Thus implement `get_window()` to allow pointer constrains to work.

Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/2223
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2717>
---
 src/wayland/meta-wayland-subsurface.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index 63150d006f..4feefae30f 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -168,6 +168,20 @@ meta_wayland_subsurface_get_toplevel (MetaWaylandSurfaceRole *surface_role)
     return NULL;
 }
 
+static MetaWindow *
+meta_wayland_subsurface_get_window (MetaWaylandSurfaceRole *surface_role)
+{
+  MetaWaylandSurface *surface =
+    meta_wayland_surface_role_get_surface (surface_role);
+  MetaWaylandSurface *parent;
+
+  parent = surface->protocol_state.parent;
+  if (parent)
+    return meta_wayland_surface_get_window (parent);
+  else
+    return NULL;
+}
+
 static gboolean
 meta_wayland_subsurface_is_synchronized (MetaWaylandSurfaceRole *surface_role)
 {
@@ -252,6 +266,7 @@ meta_wayland_subsurface_class_init (MetaWaylandSubsurfaceClass *klass)
 
   surface_role_class->assigned = meta_wayland_subsurface_assigned;
   surface_role_class->get_toplevel = meta_wayland_subsurface_get_toplevel;
+  surface_role_class->get_window = meta_wayland_subsurface_get_window;
   surface_role_class->is_synchronized = meta_wayland_subsurface_is_synchronized;
   surface_role_class->notify_subsurface_state_changed =
     meta_wayland_subsurface_notify_subsurface_state_changed;
-- 
2.39.1


From 657c24f9929f4e06514b45fadb8a3c43b1f81dfb Mon Sep 17 00:00:00 2001
From: Robert Mader <robert.mader@collabora.com>
Date: Thu, 24 Nov 2022 17:15:03 +0100
Subject: [PATCH 26/27] wayland/subsurface: Check ancestor instead of toplevel
 window for actor sync

The intention here was to check if the subsurface belongs to a window.
Thus it didn't behave as expected for subsurfaces belonging to non-toplevel
windows.

After the previous commit we can use `get_window()` to check for what we
actually want here.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2717>
---
 src/wayland/meta-wayland-subsurface.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index 4feefae30f..a979713527 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -242,10 +242,8 @@ meta_wayland_subsurface_sync_actor_state (MetaWaylandActorSurface *actor_surface
     meta_wayland_surface_role_get_surface (surface_role);
   MetaWaylandActorSurfaceClass *actor_surface_class =
     META_WAYLAND_ACTOR_SURFACE_CLASS (meta_wayland_subsurface_parent_class);
-  MetaWaylandSurface *toplevel_surface;
 
-  toplevel_surface = meta_wayland_surface_get_toplevel (surface);
-  if (toplevel_surface && meta_wayland_surface_get_window (toplevel_surface))
+  if (meta_wayland_surface_get_window (surface))
     actor_surface_class->sync_actor_state (actor_surface);
 
   sync_actor_subsurface_state (surface);
-- 
2.39.1


From ea085fa3185ffcafef79c5279d3bb944c3992066 Mon Sep 17 00:00:00 2001
From: Robert Mader <robert.mader@collabora.com>
Date: Wed, 2 Nov 2022 19:36:11 +0100
Subject: [PATCH 27/27] wayland/pointer-constraints: Adjustments for subsurface
 support

After the commit "wayland/subsurface: Implement
meta_wayland_surface_get_window()" subsurfaces are supported. Adjust
some comments and fix a warning that could occur when closing a window.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2717>
---
 src/wayland/meta-wayland-pointer-constraints.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/wayland/meta-wayland-pointer-constraints.c b/src/wayland/meta-wayland-pointer-constraints.c
index 965b95ddad..598b5fcd28 100644
--- a/src/wayland/meta-wayland-pointer-constraints.c
+++ b/src/wayland/meta-wayland-pointer-constraints.c
@@ -39,6 +39,7 @@
 #include "wayland/meta-wayland-private.h"
 #include "wayland/meta-wayland-region.h"
 #include "wayland/meta-wayland-seat.h"
+#include "wayland/meta-wayland-subsurface.h"
 #include "wayland/meta-wayland-surface.h"
 #include "wayland/meta-xwayland.h"
 
@@ -193,8 +194,6 @@ surface_constraint_data_new (MetaWaylandSurface *surface)
     }
   else
     {
-      /* TODO: Support constraints on non-toplevel windows, such as subsurfaces.
-       */
       g_warn_if_reached ();
     }
 
@@ -463,8 +462,10 @@ should_constraint_be_enabled (MetaWaylandPointerConstraint *constraint)
       /*
        * Locks from Xwayland may come before we have had the opportunity to
        * associate the X11 Window with the wl_surface.
+       * For subsurfaces the window of the ancestor might be gone already.
        */
-      g_warn_if_fail (meta_xwayland_is_xwayland_surface (constraint->surface));
+      g_warn_if_fail (meta_xwayland_is_xwayland_surface (constraint->surface) ||
+                      META_IS_WAYLAND_SUBSURFACE (constraint->surface->role));
       return FALSE;
     }
 
-- 
2.39.1

